{"/home/travis/build/npmtest/node-npmtest-orm/test.js":"/* istanbul instrument in package npmtest_orm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-orm/lib.npmtest_orm.js":"/* istanbul instrument in package npmtest_orm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_orm = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_orm = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-orm/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-orm && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_orm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_orm\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_orm.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_orm.rollup.js'] =\n            local.assetsDict['/assets.npmtest_orm.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_orm.__dirname +\n                    '/lib.npmtest_orm.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/ORM.js":"var util           = require(\"util\");\nvar events         = require(\"events\");\nvar url            = require(\"url\");\nvar hat            = require(\"hat\");\nvar Query          = require(\"sql-query\");\nvar enforce        = require(\"enforce\");\nvar _              = require(\"lodash\");\n\nvar Model          = require(\"./Model\").Model;\nvar DriverAliases  = require(\"./Drivers/aliases\");\nvar adapters       = require(\"./Adapters\");\nvar Settings       = require(\"./Settings\");\nvar Singleton      = require(\"./Singleton\");\nvar ORMError       = require(\"./Error\");\nvar Utilities      = require(\"./Utilities\");\n\n// Deprecated, use enforce\nexports.validators = require(\"./Validators\");\n\n// specific to ORM, not in enforce for now\nenforce.equalToProperty = exports.validators.equalToProperty;\nenforce.unique          = exports.validators.unique;\n\nexports.enforce    = enforce;\n\nexports.singleton  = Singleton;\nexports.settings   = new Settings.Container(Settings.defaults());\n\nexports.Property   = require(\"./Property\");\nexports.Settings   = Settings;\nexports.ErrorCodes = ORMError.codes;\n\nexports.Text = Query.Text;\nfor (var k in Query.Comparators) {\n\texports[Query.Comparators[k]] = Query[Query.Comparators[k]];\n}\n\nexports.express = function () {\n\treturn require(\"./Express\").apply(this, arguments);\n};\n\nexports.use = function (connection, proto, opts, cb) {\n\tif (DriverAliases[proto]) {\n\t\tproto = DriverAliases[proto];\n\t}\n\tif (typeof opts === \"function\") {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\n\ttry {\n\t\tvar Driver   = adapters.get(proto);\n\t\tvar settings = new Settings.Container(exports.settings.get('*'));\n\t\tvar driver   = new Driver(null, connection, {\n\t\t\tdebug    : (opts.query && opts.query.debug === 'true'),\n\t\t\tsettings : settings\n\t\t});\n\n\t\treturn cb(null, new ORM(proto, driver, settings));\n\t} catch (ex) {\n\t\treturn cb(ex);\n\t}\n};\n\nexports.connect = function (opts, cb) {\n\tif (arguments.length === 0 || !opts) {\n\t\treturn ORM_Error(new ORMError(\"CONNECTION_URL_EMPTY\", 'PARAM_MISMATCH'), cb);\n\t}\n\tif (typeof opts == 'string') {\n\t\tif (opts.trim().length === 0) {\n\t\t\treturn ORM_Error(new ORMError(\"CONNECTION_URL_EMPTY\", 'PARAM_MISMATCH'), cb);\n\t\t}\n\t\topts = url.parse(opts, true);\n\t} else if (typeof opts == 'object') {\n\t\topts = _.cloneDeep(opts);\n\t}\n\n\topts.query = opts.query || {};\n\n\tfor(var k in opts.query) {\n\t\topts.query[k] = queryParamCast(opts.query[k]);\n\t\topts[k] = opts.query[k];\n\t}\n\n\tif (!opts.database) {\n\t\t// if (!opts.pathname) {\n\t\t// \treturn cb(new Error(\"CONNECTION_URL_NO_DATABASE\"));\n\t\t// }\n\t\topts.database = (opts.pathname ? opts.pathname.substr(1) : \"\");\n\t}\n\tif (!opts.protocol) {\n\t\treturn ORM_Error(new ORMError(\"CONNECTION_URL_NO_PROTOCOL\", 'PARAM_MISMATCH'), cb);\n\t}\n\t// if (!opts.host) {\n\t// \topts.host = opts.hostname = \"localhost\";\n\t// }\n\tif (opts.auth) {\n\t\topts.user = opts.auth.split(\":\")[0];\n\t\topts.password = opts.auth.split(\":\")[1];\n\t}\n\tif (!opts.hasOwnProperty(\"user\")) {\n\t\topts.user = \"root\";\n\t}\n\tif (!opts.hasOwnProperty(\"password\")) {\n\t\topts.password = \"\";\n\t}\n\tif (opts.hasOwnProperty(\"hostname\")) {\n\t\topts.host = opts.hostname;\n\t}\n\n\tvar proto  = opts.protocol.replace(/:$/, '');\n\tvar db;\n\tif (DriverAliases[proto]) {\n\t\tproto = DriverAliases[proto];\n\t}\n\n\ttry {\n\t\tvar Driver   = adapters.get(proto);\n\t\tvar settings = new Settings.Container(exports.settings.get('*'));\n\t\tvar driver   = new Driver(opts, null, {\n\t\t\tdebug    : 'debug' in opts.query ? opts.query.debug : settings.get(\"connection.debug\"),\n\t\t\tpool     : 'pool'  in opts.query ? opts.query.pool  : settings.get(\"connection.pool\"),\n\t\t\tsettings : settings\n\t\t});\n\n\t\tdb = new ORM(proto, driver, settings);\n\n\t\tdriver.connect(function (err) {\n\t\t\tif (typeof cb === \"function\") {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb(err);\n\t\t\t\t} else {\n\t\t\t\t\treturn cb(null, db);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdb.emit(\"connect\", err, !err ? db : null);\n\t\t});\n\t} catch (ex) {\n\t\tif (ex.code === \"MODULE_NOT_FOUND\" || ex.message.indexOf('find module') > -1) {\n\t\t\treturn ORM_Error(new ORMError(\"Connection protocol not supported - have you installed the database driver for \" + proto + \"?\", 'NO_SUPPORT'), cb);\n\t\t}\n\t\treturn ORM_Error(ex, cb);\n\t}\n\n\treturn db;\n};\n\nexports.addAdapter = adapters.add;\n\nfunction ORM(driver_name, driver, settings) {\n\tthis.validators  = exports.validators;\n\tthis.enforce     = exports.enforce;\n\tthis.settings    = settings;\n\tthis.driver_name = driver_name;\n\tthis.driver      = driver;\n\tthis.driver.uid  = hat();\n\tthis.tools       = {};\n\tthis.models      = {};\n\tthis.plugins     = [];\n\tthis.customTypes = {};\n\n\tfor (var k in Query.Comparators) {\n\t\tthis.tools[Query.Comparators[k]] = Query[Query.Comparators[k]];\n\t}\n\n\tevents.EventEmitter.call(this);\n\n\tvar onError = function (err) {\n\t\tif (this.settings.get(\"connection.reconnect\")) {\n\t\t\tif (typeof this.driver.reconnect === \"undefined\") {\n\t\t\t\treturn this.emit(\"error\", new ORMError(\"Connection lost - driver does not support reconnection\", 'CONNECTION_LOST'));\n\t\t\t}\n\t\t\tthis.driver.reconnect(function () {\n\t\t\t\tthis.driver.on(\"error\", onError);\n\t\t\t}.bind(this));\n\n\t\t\tif (this.listeners(\"error\").length === 0) {\n\t\t\t\t// since user want auto reconnect,\n\t\t\t\t// don't emit without listeners or it will throw\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.emit(\"error\", err);\n\t}.bind(this);\n\n\tdriver.on(\"error\", onError);\n}\n\nutil.inherits(ORM, events.EventEmitter);\n\nORM.prototype.use = function (plugin_const, opts) {\n\tif (typeof plugin_const === \"string\") {\n\t\ttry {\n\t\t\tplugin_const = require(Utilities.getRealPath(plugin_const));\n\t\t} catch (e) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tvar plugin = new plugin_const(this, opts || {});\n\n\tif (typeof plugin.define === \"function\") {\n\t\tfor (var k in this.models) {\n\t\t\tplugin.define(this.models[k]);\n\t\t}\n\t}\n\n\tthis.plugins.push(plugin);\n\n\treturn this;\n};\nORM.prototype.define = function (name, properties, opts) {\n    var i;\n\n\tproperties = properties || {};\n\topts       = opts || {};\n\n\tfor (i = 0; i < this.plugins.length; i++) {\n\t\tif (typeof this.plugins[i].beforeDefine === \"function\") {\n\t\t\tthis.plugins[i].beforeDefine(name, properties, opts);\n\t\t}\n\t}\n\n\tthis.models[name] = new Model({\n\t\tdb             : this,\n\t\tsettings       : this.settings,\n\t\tdriver_name    : this.driver_name,\n\t\tdriver         : this.driver,\n\t\ttable          : opts.table || opts.collection || ((this.settings.get(\"model.namePrefix\") || \"\") + name),\n\t\tproperties     : properties,\n\t\textension      : opts.extension || false,\n\t\tindexes        : opts.indexes || [],\n\t\tidentityCache       : opts.hasOwnProperty(\"identityCache\") ? opts.identityCache : this.settings.get(\"instance.identityCache\"),\n\t\tkeys           : opts.id,\n\t\tautoSave       : opts.hasOwnProperty(\"autoSave\") ? opts.autoSave : this.settings.get(\"instance.autoSave\"),\n\t\tautoFetch      : opts.hasOwnProperty(\"autoFetch\") ? opts.autoFetch : this.settings.get(\"instance.autoFetch\"),\n\t\tautoFetchLimit : opts.autoFetchLimit || this.settings.get(\"instance.autoFetchLimit\"),\n\t\tcascadeRemove  : opts.hasOwnProperty(\"cascadeRemove\") ? opts.cascadeRemove : this.settings.get(\"instance.cascadeRemove\"),\n\t\thooks          : opts.hooks || {},\n\t\tmethods        : opts.methods || {},\n\t\tvalidations    : opts.validations || {}\n\t});\n\n\tfor (i = 0; i < this.plugins.length; i++) {\n\t\tif (typeof this.plugins[i].define === \"function\") {\n\t\t\tthis.plugins[i].define(this.models[name], this);\n\t\t}\n\t}\n\n\treturn this.models[name];\n};\nORM.prototype.defineType = function (name, opts) {\n\tthis.customTypes[name] = opts;\n\tthis.driver.customTypes[name] = opts;\n\treturn this;\n};\nORM.prototype.ping = function (cb) {\n\tthis.driver.ping(cb);\n\n\treturn this;\n};\nORM.prototype.close = function (cb) {\n\tthis.driver.close(cb);\n\n\treturn this;\n};\nORM.prototype.load = function () {\n\tvar files = _.flatten(Array.prototype.slice.apply(arguments));\n\tvar cb    = function () {};\n\n\tif (typeof files[files.length - 1] == \"function\") {\n\t\tcb = files.pop();\n\t}\n\n\tvar loadNext = function () {\n\t\tif (files.length === 0) {\n\t\t\treturn cb();\n\t\t}\n\n\t\tvar file = files.shift();\n\n\t\ttry {\n\t\t\treturn require(Utilities.getRealPath(file, 4))(this, function (err) {\n\t\t\t\tif (err) return cb(err);\n\n\t\t\t\treturn loadNext();\n\t\t\t});\n\t\t} catch (ex) {\n\t\t\treturn cb(ex);\n\t\t}\n\t}.bind(this);\n\n\treturn loadNext();\n};\nORM.prototype.sync = function (cb) {\n\tvar modelIds = Object.keys(this.models);\n\tvar syncNext = function () {\n\t\tif (modelIds.length === 0) {\n\t\t\treturn cb();\n\t\t}\n\n\t\tvar modelId = modelIds.shift();\n\n\t\tthis.models[modelId].sync(function (err) {\n\t\t\tif (err) {\n\t\t\t\terr.model = modelId;\n\n\t\t\t\treturn cb(err);\n\t\t\t}\n\n\t\t\treturn syncNext();\n\t\t});\n\t}.bind(this);\n\n\tif (arguments.length === 0) {\n\t\tcb = function () {};\n\t}\n\n\tsyncNext();\n\n\treturn this;\n};\nORM.prototype.drop = function (cb) {\n\tvar modelIds = Object.keys(this.models);\n\tvar dropNext = function () {\n\t\tif (modelIds.length === 0) {\n\t\t\treturn cb();\n\t\t}\n\n\t\tvar modelId = modelIds.shift();\n\n\t\tthis.models[modelId].drop(function (err) {\n\t\t\tif (err) {\n\t\t\t\terr.model = modelId;\n\n\t\t\t\treturn cb(err);\n\t\t\t}\n\n\t\t\treturn dropNext();\n\t\t});\n\t}.bind(this);\n\n\tif (arguments.length === 0) {\n\t\tcb = function () {};\n\t}\n\n\tdropNext();\n\n\treturn this;\n};\nORM.prototype.serial = function () {\n\tvar chains = Array.prototype.slice.apply(arguments);\n\n\treturn {\n\t\tget: function (cb) {\n\t\t\tvar params = [];\n\t\t\tvar getNext = function () {\n\t\t\t\tif (params.length === chains.length) {\n\t\t\t\t\tparams.unshift(null);\n\t\t\t\t\treturn cb.apply(null, params);\n\t\t\t\t}\n\n\t\t\t\tchains[params.length].run(function (err, instances) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tparams.unshift(err);\n\t\t\t\t\t\treturn cb.apply(null, params);\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.push(instances);\n\t\t\t\t\treturn getNext();\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tgetNext();\n\n\t\t\treturn this;\n\t\t}\n\t};\n};\n\nfunction ORM_Error(err, cb) {\n\tvar Emitter = new events.EventEmitter();\n\n\tEmitter.use = Emitter.define = Emitter.sync = Emitter.load = function () {};\n\n\tif (typeof cb === \"function\") {\n\t\tcb(err);\n\t}\n\n\tprocess.nextTick(function () {\n\t\tEmitter.emit(\"connect\", err);\n\t});\n\n\treturn Emitter;\n}\n\nfunction queryParamCast (val) {\n\tif (typeof val == 'string')\t{\n\t\tswitch (val) {\n\t\t\tcase '1':\n\t\t\tcase 'true':\n\t\t\t\treturn true;\n\t\t\tcase '0':\n\t\t\tcase 'false':\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn val;\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Model.js":"var _                 = require(\"lodash\");\nvar async             = require(\"async\");\nvar ChainFind         = require(\"./ChainFind\");\nvar Instance          = require(\"./Instance\").Instance;\nvar LazyLoad          = require(\"./LazyLoad\");\nvar ManyAssociation   = require(\"./Associations/Many\");\nvar OneAssociation    = require(\"./Associations/One\");\nvar ExtendAssociation = require(\"./Associations/Extend\");\nvar Property          = require(\"./Property\");\nvar Singleton         = require(\"./Singleton\");\nvar Utilities         = require(\"./Utilities\");\nvar Validators        = require(\"./Validators\");\nvar ORMError          = require(\"./Error\");\nvar Hook              = require(\"./Hook\");\nvar AvailableHooks    = [\n\t\"beforeCreate\", \"afterCreate\",\n\t\"beforeSave\", \"afterSave\",\n\t\"beforeValidation\",\n\t\"beforeRemove\", \"afterRemove\",\n\t\"afterLoad\",\n\t\"afterAutoFetch\"\n];\n\nexports.Model = Model;\n\nfunction Model(opts) {\n\topts = _.defaults(opts || {}, {\n\t\tkeys: []\n\t});\n\topts.keys = Array.isArray(opts.keys) ? opts.keys : [opts.keys];\n\n\tvar one_associations       = [];\n\tvar many_associations      = [];\n\tvar extend_associations    = [];\n\tvar association_properties = [];\n\tvar model_fields           = [];\n\tvar fieldToPropertyMap     = {};\n\tvar allProperties          = {};\n\tvar keyProperties          = [];\n\n\tvar createHookHelper = function (hook) {\n\t\treturn function (cb) {\n\t\t\tif (typeof cb !== \"function\") {\n\t\t\t\tdelete opts.hooks[hook];\n\t\t\t} else {\n\t\t\t\topts.hooks[hook] = cb;\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\t};\n\tvar createInstance = function (data, inst_opts, cb) {\n\t\tif (!inst_opts) {\n\t\t\tinst_opts = {};\n\t\t}\n\n\t\tvar found_assoc = false, i, k;\n\n\t\tfor (k in data) {\n\t\t\tif (k === \"extra_field\") continue;\n\t\t\tif (opts.properties.hasOwnProperty(k)) continue;\n\t\t\tif (inst_opts.extra && inst_opts.extra.hasOwnProperty(k)) continue;\n\t\t\tif (opts.keys.indexOf(k) >= 0) continue;\n\t\t\tif (association_properties.indexOf(k) >= 0) continue;\n\n\t\t\tfor (i = 0; i < one_associations.length; i++) {\n\t\t\t\tif (one_associations[i].name === k) {\n\t\t\t\t\tfound_assoc = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found_assoc) {\n\t\t\t\tfor (i = 0; i < many_associations.length; i++) {\n\t\t\t\t\tif (many_associations[i].name === k) {\n\t\t\t\t\t\tfound_assoc = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found_assoc) {\n\t\t\t\tdelete data[k];\n\t\t\t}\n\t\t}\n\n\t\tvar assoc_opts = {\n\t\t\tautoFetch      : inst_opts.autoFetch || false,\n\t\t\tautoFetchLimit : inst_opts.autoFetchLimit,\n\t\t\tcascadeRemove  : inst_opts.cascadeRemove\n\t\t};\n\n\t\tvar setupAssociations = function (instance) {\n\t\t\tOneAssociation.extend(model, instance, opts.driver, one_associations, assoc_opts);\n\t\t\tManyAssociation.extend(model, instance, opts.driver, many_associations, assoc_opts, createInstance);\n\t\t\tExtendAssociation.extend(model, instance, opts.driver, extend_associations, assoc_opts);\n\t\t};\n\n\t\tvar pending  = 2, create_err = null;\n\t\tvar instance = new Instance(model, {\n\t\t\tuid                    : inst_opts.uid, // singleton unique id\n\t\t\tkeys                   : opts.keys,\n\t\t\tis_new                 : inst_opts.is_new || false,\n\t\t\tisShell                : inst_opts.isShell || false,\n\t\t\tdata                   : data,\n\t\t\tautoSave               : inst_opts.autoSave || false,\n\t\t\textra                  : inst_opts.extra,\n\t\t\textra_info             : inst_opts.extra_info,\n\t\t\tdriver                 : opts.driver,\n\t\t\ttable                  : opts.table,\n\t\t\thooks                  : opts.hooks,\n\t\t\tmethods                : opts.methods,\n\t\t\tvalidations            : opts.validations,\n\t\t\tone_associations       : one_associations,\n\t\t\tmany_associations      : many_associations,\n\t\t\textend_associations    : extend_associations,\n\t\t\tassociation_properties : association_properties,\n\t\t\tsetupAssociations      : setupAssociations,\n\t\t\tfieldToPropertyMap     : fieldToPropertyMap,\n\t\t\tkeyProperties          : keyProperties\n\t\t});\n\t\tinstance.on(\"ready\", function (err) {\n\t\t\tif (--pending > 0) {\n\t\t\t\tcreate_err = err;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (typeof cb === \"function\") {\n\t\t\t\treturn cb(err || create_err, instance);\n\t\t\t}\n\t\t});\n\t\tif (model_fields !== null) {\n\t\t\tLazyLoad.extend(instance, model, opts.properties);\n\t\t}\n\n\t\tOneAssociation.autoFetch(instance, one_associations, assoc_opts, function () {\n\t\t\tManyAssociation.autoFetch(instance, many_associations, assoc_opts, function () {\n\t\t\t\tExtendAssociation.autoFetch(instance, extend_associations, assoc_opts, function () {\n\t\t\t\t\tHook.wait(instance, opts.hooks.afterAutoFetch, function (err) {\n\t\t\t\t\t\tif (--pending > 0) {\n\t\t\t\t\t\t\tcreate_err = err;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof cb === \"function\") {\n\t\t\t\t\t\t\treturn cb(err || create_err, instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\treturn instance;\n\t};\n\n\tvar model = function () {\n\t    var instance, i;\n\n\t    var data = arguments.length > 1 ? arguments : arguments[0];\n\n\t    if (Array.isArray(opts.keys) && Array.isArray(data)) {\n\t        if (data.length == opts.keys.length) {\n\t            var data2 = {};\n\t            for (i = 0; i < opts.keys.length; i++) {\n\t                data2[opts.keys[i]] = data[i++];\n\t            }\n\n\t            return createInstance(data2, { isShell: true });\n\t        }\n\t        else {\n\t            var err = new Error('Model requires ' + opts.keys.length + ' keys, only ' + data.length + ' were provided');\n\t            err.model = opts.table;\n\n\t            throw err;\n\t        }\n\t    }\n\t    else if (typeof data === \"number\" || typeof data === \"string\") {\n\t        var data2 = {};\n\t        data2[opts.keys[0]] = data;\n\n\t        return createInstance(data2, { isShell: true });\n\t    } else if (typeof data === \"undefined\") {\n\t        data = {};\n\t    }\n\n\t    var isNew = false;\n\n\t    for (i = 0; i < opts.keys.length; i++) {\n\t        if (!data.hasOwnProperty(opts.keys[i])) {\n\t            isNew = true;\n\t            break;\n\t        }\n\t    }\n\n      if (keyProperties.length != 1 || (keyProperties.length == 1 && keyProperties[0].type != 'serial')) {\n        isNew = true;\n      }\n\n\t    return createInstance(data, {\n\t        is_new: isNew,\n\t        autoSave: opts.autoSave,\n\t        cascadeRemove: opts.cascadeRemove\n\t    });\n\t};\n\n\tmodel.allProperties = allProperties;\n\tmodel.properties    = opts.properties;\n\tmodel.settings      = opts.settings;\n\tmodel.keys          = opts.keys;\n\n\tmodel.drop = function (cb) {\n\t\tif (arguments.length === 0) {\n\t\t\tcb = function () {};\n\t\t}\n\t\tif (typeof opts.driver.drop === \"function\") {\n\t\t\topts.driver.drop({\n\t\t\t\ttable             : opts.table,\n\t\t\t\tproperties        : opts.properties,\n\t\t\t\tone_associations  : one_associations,\n\t\t\t\tmany_associations : many_associations\n\t\t\t}, cb);\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn cb(new ORMError(\"Driver does not support Model.drop()\", 'NO_SUPPORT', { model: opts.table }));\n\t};\n\n\tmodel.sync = function (cb) {\n\t\tif (arguments.length === 0) {\n\t\t\tcb = function () {};\n\t\t}\n\t\tif (typeof opts.driver.sync === \"function\") {\n\t\t\ttry {\n\t\t\t\topts.driver.sync({\n\t\t\t\t\textension           : opts.extension,\n\t\t\t\t\tid                  : opts.keys,\n\t\t\t\t\ttable               : opts.table,\n\t\t\t\t\tproperties          : opts.properties,\n\t\t\t\t\tallProperties       : allProperties,\n\t\t\t\t\tindexes             : opts.indexes || [],\n\t\t\t\t\tcustomTypes         : opts.db.customTypes,\n\t\t\t\t\tone_associations    : one_associations,\n\t\t\t\t\tmany_associations   : many_associations,\n\t\t\t\t\textend_associations : extend_associations\n\t\t\t\t}, cb);\n\t\t\t} catch (e) {\n\t\t\t\treturn cb(e);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn cb(new ORMError(\"Driver does not support Model.sync()\", 'NO_SUPPORT', { model: opts.table }));\n\t};\n\n\tmodel.get = function () {\n\t\tvar conditions = {};\n\t\tvar options    = {};\n\t\tvar ids        = Array.prototype.slice.apply(arguments);\n\t\tvar cb         = ids.pop();\n\t\tvar prop;\n\n\t\tif (typeof cb !== \"function\") {\n\t\t    throw new ORMError(\"Missing Model.get() callback\", 'MISSING_CALLBACK', { model: opts.table });\n\t\t}\n\n\t\tif (typeof ids[ids.length - 1] === \"object\" && !Array.isArray(ids[ids.length - 1])) {\n\t\t\toptions = ids.pop();\n\t\t}\n\n\t\tif (ids.length === 1 && Array.isArray(ids[0])) {\n\t\t\tids = ids[0];\n\t\t}\n\n\t\tif (ids.length !== opts.keys.length) {\n\t\t    throw new ORMError(\"Model.get() IDs number mismatch (\" + opts.keys.length + \" needed, \" + ids.length + \" passed)\", 'PARAM_MISMATCH', { model: opts.table });\n\t\t}\n\n\t\tfor (var i = 0; i < keyProperties.length; i++) {\n\t\t\tprop = keyProperties[i];\n\t\t\tconditions[prop.mapsTo] = ids[i];\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"autoFetch\")) {\n\t\t\toptions.autoFetch = opts.autoFetch;\n\t\t}\n\t\tif (!options.hasOwnProperty(\"autoFetchLimit\")) {\n\t\t\toptions.autoFetchLimit = opts.autoFetchLimit;\n\t\t}\n\t\tif (!options.hasOwnProperty(\"cascadeRemove\")) {\n\t\t\toptions.cascadeRemove = opts.cascadeRemove;\n\t\t}\n\n\t\topts.driver.find(model_fields, opts.table, conditions, { limit: 1 }, function (err, data) {\n\t\t\tif (err) {\n\t\t\t\treturn cb(new ORMError(err.message, 'QUERY_ERROR', { originalCode: err.code }));\n\t\t\t}\n\t\t\tif (data.length === 0) {\n\t\t\t\treturn cb(new ORMError(\"Not found\", 'NOT_FOUND', { model: opts.table }));\n\t\t\t}\n\n\t\t\tUtilities.renameDatastoreFieldsToPropertyNames(data[0], fieldToPropertyMap);\n\n\t\t\tvar uid = opts.driver.uid + \"/\" + opts.table + \"/\" + ids.join(\"/\");\n\n\t\t\tSingleton.get(uid, {\n\t\t\t\tidentityCache : (options.hasOwnProperty(\"identityCache\") ? options.identityCache : opts.identityCache),\n\t\t\t\tsaveCheck     : opts.settings.get(\"instance.identityCacheSaveCheck\")\n\t\t\t}, function (cb) {\n\t\t\t\treturn createInstance(data[0], {\n\t\t\t\t\tuid            : uid,\n\t\t\t\t\tautoSave       : options.autoSave,\n\t\t\t\t\tautoFetch      : (options.autoFetchLimit === 0 ? false : options.autoFetch),\n\t\t\t\t\tautoFetchLimit : options.autoFetchLimit,\n\t\t\t\t\tcascadeRemove  : options.cascadeRemove\n\t\t\t\t}, cb);\n\t\t\t}, cb);\n\t\t});\n\n\t\treturn this;\n\t};\n\n\tmodel.find = function () {\n\t\tvar options    = {};\n\t\tvar conditions = null;\n\t\tvar cb         = null;\n\t\tvar order      = null;\n\t\tvar merge      = null;\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\toptions.limit = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"object\":\n\t\t\t\t\tif (Array.isArray(arguments[i])) {\n\t\t\t\t\t\tif (arguments[i].length > 0) {\n\t\t\t\t\t\t\torder = arguments[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (conditions === null) {\n\t\t\t\t\t\t\tconditions = arguments[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (options.hasOwnProperty(\"limit\")) {\n\t\t\t\t\t\t\t\targuments[i].limit = options.limit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toptions = arguments[i];\n\n\t\t\t\t\t\t\tif (options.hasOwnProperty(\"__merge\")) {\n\t\t\t\t\t\t\t\tmerge = options.__merge;\n\t\t\t\t\t\t\t\tmerge.select = Object.keys(options.extra);\n\t\t\t\t\t\t\t\tdelete options.__merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (options.hasOwnProperty(\"order\")) {\n\t\t\t\t\t\t\t\torder = options.order;\n\t\t\t\t\t\t\t\tdelete options.order;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tcb = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"string\":\n\t\t\t\t\tif (arguments[i][0] === \"-\") {\n\t\t\t\t\t\torder = [ arguments[i].substr(1), \"Z\" ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\torder = [ arguments[i] ];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"identityCache\")) {\n\t\t\toptions.identityCache = opts.identityCache;\n\t\t}\n\t\tif (!options.hasOwnProperty(\"autoFetchLimit\")) {\n\t\t\toptions.autoFetchLimit = opts.autoFetchLimit;\n\t\t}\n\t\tif (!options.hasOwnProperty(\"cascadeRemove\")) {\n\t\t\toptions.cascadeRemove = opts.cascadeRemove;\n\t\t}\n\n\t\tif (order) {\n\t\t\torder = Utilities.standardizeOrder(order);\n\t\t}\n\t\tif (conditions) {\n\t\t\tconditions = Utilities.checkConditions(conditions, one_associations);\n\t\t}\n\n\t\tvar chain = new ChainFind(model, {\n\t\t\tonly         : options.only || model_fields,\n\t\t\tkeys         : opts.keys,\n\t\t\ttable        : opts.table,\n\t\t\tdriver       : opts.driver,\n\t\t\tconditions   : conditions,\n\t\t\tassociations : many_associations,\n\t\t\tlimit        : options.limit,\n\t\t\torder        : order,\n\t\t\tmerge        : merge,\n\t\t\toffset       : options.offset,\n\t\t\tproperties   : allProperties,\n\t\t\tkeyProperties: keyProperties,\n\t\t\tnewInstance  : function (data, cb) {\n\t\t\t\t// We need to do the rename before we construct the UID & do the cache lookup\n\t\t\t\t// because the cache is loaded using propertyName rather than fieldName\n\t\t\t\tUtilities.renameDatastoreFieldsToPropertyNames(data, fieldToPropertyMap);\n\n\t\t\t\t// Construct UID\n\t\t\t\tvar uid = opts.driver.uid + \"/\" + opts.table + (merge ? \"+\" + merge.from.table : \"\");\n\t\t\t\tfor (var i = 0; i < opts.keys.length; i++) {\n\t\t\t\t\tuid += \"/\" + data[opts.keys[i]];\n\t\t\t\t}\n\n\t\t\t\t// Now we can do the cache lookup\n\t\t\t\tSingleton.get(uid, {\n\t\t\t\t\tidentityCache : options.identityCache,\n\t\t\t\t\tsaveCheck     : opts.settings.get(\"instance.identityCacheSaveCheck\")\n\t\t\t\t}, function (cb) {\n\t\t\t\t\treturn createInstance(data, {\n\t\t\t\t\t\tuid            : uid,\n\t\t\t\t\t\tautoSave       : opts.autoSave,\n\t\t\t\t\t\tautoFetch      : (options.autoFetchLimit === 0 ? false : (options.autoFetch || opts.autoFetch)),\n\t\t\t\t\t\tautoFetchLimit : options.autoFetchLimit,\n\t\t\t\t\t\tcascadeRemove  : options.cascadeRemove,\n\t\t\t\t\t\textra          : options.extra,\n\t\t\t\t\t\textra_info     : options.extra_info\n\t\t\t\t\t}, cb);\n\t\t\t\t}, cb);\n\t\t\t}\n\t\t});\n\n\t\tif (typeof cb !== \"function\") {\n\t\t\treturn chain;\n\t\t} else {\n\t\t\tchain.run(cb);\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tmodel.where = model.all = model.find;\n\n\tmodel.one = function () {\n\t\tvar args = Array.prototype.slice.apply(arguments);\n\t\tvar cb   = null;\n\n\t\t// extract callback\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tif (typeof args[i] === \"function\") {\n\t\t\t\tcb = args.splice(i, 1)[0];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cb === null) {\n\t\t    throw new ORMError(\"Missing Model.one() callback\", 'MISSING_CALLBACK', { model: opts.table });\n\t\t}\n\n\t\t// add limit 1\n\t\targs.push(1);\n\t\targs.push(function (err, results) {\n\t\t\tif (err) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t\treturn cb(null, results.length ? results[0] : null);\n\t\t});\n\n\t\treturn this.find.apply(this, args);\n\t};\n\n\tmodel.count = function () {\n\t\tvar conditions = null;\n\t\tvar cb         = null;\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\tconditions = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tcb = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof cb !== \"function\") {\n\t\t    throw new ORMError('MISSING_CALLBACK', \"Missing Model.count() callback\", { model: opts.table });\n\t\t}\n\n\t\tif (conditions) {\n\t\t\tconditions = Utilities.checkConditions(conditions, one_associations);\n\t\t}\n\n\t\topts.driver.count(opts.table, conditions, {}, function (err, data) {\n\t\t\tif (err || data.length === 0) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t\treturn cb(null, data[0].c);\n\t\t});\n\t\treturn this;\n\t};\n\n\tmodel.aggregate = function () {\n\t\tvar conditions = {};\n\t\tvar propertyList = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tif (typeof arguments[i] === \"object\") {\n\t\t\t\tif (Array.isArray(arguments[i])) {\n\t\t\t\t\tpropertyList = arguments[i];\n\t\t\t\t} else {\n\t\t\t\t\tconditions = arguments[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conditions) {\n\t\t\tconditions = Utilities.checkConditions(conditions, one_associations);\n\t\t}\n\n\t\treturn new require(\"./AggregateFunctions\")({\n\t\t\ttable        : opts.table,\n\t\t\tdriver_name  : opts.driver_name,\n\t\t\tdriver       : opts.driver,\n\t\t\tconditions   : conditions,\n\t\t\tpropertyList : propertyList,\n\t\t\tproperties   : allProperties\n\t\t});\n\t};\n\n\tmodel.exists = function () {\n\t\tvar ids = Array.prototype.slice.apply(arguments);\n\t\tvar cb  = ids.pop();\n\n\t\tif (typeof cb !== \"function\") {\n\t\t    throw new ORMError(\"Missing Model.exists() callback\", 'MISSING_CALLBACK', { model: opts.table });\n\t\t}\n\n\t\tvar conditions = {}, i;\n\n\t\tif (ids.length === 1 && typeof ids[0] === \"object\") {\n\t\t\tif (Array.isArray(ids[0])) {\n\t\t\t\tfor (i = 0; i < opts.keys.length; i++) {\n\t\t\t\t\tconditions[opts.keys[i]] = ids[0][i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconditions = ids[0];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < opts.keys.length; i++) {\n\t\t\t\tconditions[opts.keys[i]] = ids[i];\n\t\t\t}\n\t\t}\n\n\t\tif (conditions) {\n\t\t\tconditions = Utilities.checkConditions(conditions, one_associations);\n\t\t}\n\n\t\topts.driver.count(opts.table, conditions, {}, function (err, data) {\n\t\t\tif (err || data.length === 0) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t\treturn cb(null, data[0].c > 0);\n\t\t});\n\t\treturn this;\n\t};\n\n\tmodel.create = function () {\n\t\tvar itemsParams = []\n\t\tvar items       = [];\n\t\tvar options     = {};\n\t\tvar done        = null;\n\t\tvar single      = false;\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\tif ( !single && Array.isArray(arguments[i]) ) {\n\t\t\t\t\t\titemsParams = itemsParams.concat(arguments[i]);\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\tsingle = true;\n\t\t\t\t\t\titemsParams.push(arguments[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions = arguments[i];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tdone = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar iterator = function (params, index, cb) {\n\t\t\tcreateInstance(params, {\n\t\t\t\tis_new    : true,\n\t\t\t\tautoSave  : opts.autoSave,\n\t\t\t\tautoFetch : false\n\t\t\t}, function (err, item) {\n\t\t\t\tif (err) {\n\t\t\t\t\terr.index    = index;\n\t\t\t\t\terr.instance = item;\n\n\t\t\t\t\treturn cb(err);\n\t\t\t\t}\n\t\t\t\titem.save(function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\terr.index    = index;\n\t\t\t\t\t\terr.instance = item;\n\n\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t}\n\n\t\t\t\t\titems[index] = item;\n\t\t\t\t\tcb();\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tasync.eachOfSeries(itemsParams, iterator, function (err) {\n\t\t\tif (err) return done(err);\n\t\t\tdone(null, single ? items[0] : items);\n\t\t});\n\n\t\treturn this;\n\t};\n\n\tmodel.clear = function (cb) {\n\t\topts.driver.clear(opts.table, function (err) {\n\t\t\tif (typeof cb === \"function\") cb(err);\n\t\t});\n\n\t\treturn this;\n\t};\n\n\tmodel.prependValidation = function (key, validation) {\n\t\tif(opts.validations.hasOwnProperty(key)) {\n\t\t\topts.validations[key].splice(0, 0, validation);\n\t\t} else {\n\t\t\topts.validations[key] = [validation];\n\t\t}\n\t};\n\n\tvar currFields = {};\n\n\tmodel.addProperty = function (propIn, options) {\n\t\tvar cType;\n\t\tvar prop = Property.normalize({\n\t\t\tprop: propIn, name: (options && options.name || propIn.name),\n\t\t\tcustomTypes: opts.db.customTypes, settings: opts.settings\n\t\t});\n\n\t\t// Maintains backwards compatibility\n\t\tif (opts.keys.indexOf(k) != -1) {\n\t\t\tprop.key = true;\n\t\t} else if (prop.key) {\n\t\t\topts.keys.push(k);\n\t\t}\n\n\t\tif (options && options.klass) {\n\t\t\tprop.klass = options.klass;\n\t\t}\n\n\t\tswitch (prop.klass) {\n\t\t\tcase 'primary':\n\t\t\t\topts.properties[prop.name]  = prop;\n\t\t\t\tbreak;\n\t\t\tcase 'hasOne':\n\t\t\t\tassociation_properties.push(prop.name)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tallProperties[prop.name]        = prop;\n\t\tfieldToPropertyMap[prop.mapsTo] = prop;\n\n\t\tif (prop.required) {\n\t\t\tmodel.prependValidation(prop.name, Validators.required());\n\t\t}\n\n\t\tif (prop.key && prop.klass == 'primary') {\n\t\t\tkeyProperties.push(prop);\n\t\t}\n\n\t\tif (prop.lazyload !== true && !currFields[prop.name]) {\n\t\t\tcurrFields[prop.name] = true;\n\t\t\tif ((cType = opts.db.customTypes[prop.type]) && cType.datastoreGet) {\n\t\t\t\tmodel_fields.push({\n\t\t\t\t\ta: prop.mapsTo, sql: cType.datastoreGet(prop, opts.db.driver.query)\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tmodel_fields.push(prop.mapsTo);\n\t\t\t}\n\t\t}\n\n\t\treturn prop;\n\t};\n\n\tObject.defineProperty(model, \"table\", {\n\t\tvalue: opts.table,\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(model, \"id\", {\n\t\tvalue: opts.keys,\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(model, \"uid\", {\n\t    value: opts.driver.uid + \"/\" + opts.table + \"/\" + opts.keys.join(\"/\"),\n        enumerable: false\n\t});\n\n\t// Standardize validations\n\tfor (var k in opts.validations) {\n\t\tif (!Array.isArray(opts.validations[k])) {\n\t\t\topts.validations[k] = [ opts.validations[k] ];\n\t\t}\n\t}\n\n\t// If no keys are defined add the default one\n\tif (opts.keys.length == 0 && !_.some(opts.properties, { key: true })) {\n\t\topts.properties[opts.settings.get(\"properties.primary_key\")] = {\n\t\t\ttype: 'serial', key: true, required: false, klass: 'primary'\n\t\t};\n\t}\n\n\t// standardize properties\n\tfor (k in opts.properties) {\n\t\tmodel.addProperty(opts.properties[k], { name: k, klass: 'primary' });\n\t}\n\n\tif (keyProperties.length == 0) {\n\t\tthrow new ORMError(\"Model defined without any keys\", 'BAD_MODEL', { model: opts.table });\n\t}\n\n\t// setup hooks\n\tfor (k in AvailableHooks) {\n\t\tmodel[AvailableHooks[k]] = createHookHelper(AvailableHooks[k]);\n\t}\n\n\tOneAssociation.prepare(model, one_associations);\n\tManyAssociation.prepare(opts.db, model, many_associations);\n\tExtendAssociation.prepare(opts.db, model, extend_associations);\n\n\treturn model;\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/ChainFind.js":"var _             = require(\"lodash\");\nvar async         = require(\"async\");\nvar Utilities     = require(\"./Utilities\");\nvar ChainInstance = require(\"./ChainInstance\");\nvar Promise       = require(\"./Promise\").Promise;\n\nmodule.exports = ChainFind;\n\nfunction ChainFind(Model, opts) {\n\tvar prepareConditions = function () {\n\t\treturn Utilities.transformPropertyNames(\n\t\t\topts.conditions, opts.properties\n\t\t);\n\t};\n\n\tvar prepareOrder = function () {\n\t\treturn Utilities.transformOrderPropertyNames(\n\t\t\topts.order, opts.properties\n\t\t);\n\t};\n\n\tvar chainRun = function (done) {\n\t\tvar order, conditions;\n\n\t\tconditions = Utilities.transformPropertyNames(\n\t\t\topts.conditions, opts.properties\n\t\t);\n\t\torder = Utilities.transformOrderPropertyNames(\n\t\t\topts.order, opts.properties\n\t\t);\n\n\t\topts.driver.find(opts.only, opts.table, conditions, {\n\t\t\tlimit  : opts.limit,\n\t\t\torder  : order,\n\t\t\tmerge  : opts.merge,\n\t\t\toffset : opts.offset,\n\t\t\texists : opts.exists\n\t\t}, function (err, dataItems) {\n\t\t\tif (err) {\n\t\t\t\treturn done(err);\n\t\t\t}\n\t\t\tif (dataItems.length === 0) {\n\t\t\t\treturn done(null, []);\n\t\t\t}\n\t\t\tvar pending = dataItems.length;\n\n\t\t\tvar eagerLoad = function (err, items) {\n\t\t\t\tvar pending = opts.__eager.length;\n\t\t\t\tvar idMap = {};\n\n\t\t\t\tvar keys = _.map(items, function (item, index) {\n\t\t\t\t\tvar key = item[opts.keys[0]];\n\t\t\t\t\t// Create the association arrays\n\t\t\t\t\tfor (var i = 0, association; association = opts.__eager[i]; i++) {\n\t\t\t\t\t\titem[association.name] = [];\n\t\t\t\t\t}\n\t\t\t\t\tidMap[key] = index;\n\n\t\t\t\t\treturn key;\n\t\t\t\t});\n\n\t\t\t\tasync.eachSeries(opts.__eager,\n\t\t\t\t\tfunction (association, cb) {\n\t\t\t\t\t\topts.driver.eagerQuery(association, opts, keys, function (err, instances) {\n\t\t\t\t\t\t\tif (err) return cb(err)\n\n\t\t\t\t\t\t\tfor (var i = 0, instance; instance = instances[i]; i++) {\n\t\t\t\t\t\t\t\t// Perform a parent lookup with $p, and initialize it as an instance.\n\t\t\t\t\t\t\t\titems[idMap[instance.$p]][association.name].push(association.model(instance));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tfunction (err) {\n\t\t\t\t\t\tif (err) done(err);\n\t\t\t\t\t\telse done(null, items);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t};\n\n\t\t\tasync.map(dataItems, opts.newInstance, function (err, items) {\n\t\t\t\tif (err) return done(err);\n\n\t\t\t\tvar shouldEagerLoad = opts.__eager && opts.__eager.length;\n\t\t\t\tvar completeFn = shouldEagerLoad ? eagerLoad : done;\n\n\t\t\t\treturn completeFn(null, items);\n\t\t\t});\n\t\t});\n\t}\n\n\tvar promise = null;\n\tvar chain = {\n\t\tfind: function () {\n\t\t\tvar cb = null;\n\n\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\topts.conditions = opts.conditions || {};\n\n\t\t\tif (typeof _.last(args) === \"function\") {\n\t\t\t    cb = args.pop();\n\t\t\t}\n\n\t\t\tif (typeof args[0] === \"object\") {\n\t\t\t\t_.extend(opts.conditions, args[0]);\n\t\t\t} else if (typeof args[0] === \"string\") {\n\t\t\t\topts.conditions.__sql = opts.conditions.__sql || [];\n\t\t\t\topts.conditions.__sql.push(args);\n\t\t\t}\n\n\t\t\tif (cb) {\n\t\t\t\tchainRun(cb);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tonly: function () {\n\t\t\tif (arguments.length && Array.isArray(arguments[0])) {\n\t\t\t\topts.only = arguments[0];\n\t\t\t} else {\n\t\t\t\topts.only = Array.prototype.slice.apply(arguments);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tomit: function () {\n\t\t\tvar omit = null;\n\n\t\t\tif (arguments.length && Array.isArray(arguments[0])) {\n\t\t\t\tomit = arguments[0];\n\t\t\t} else {\n\t\t\t\tomit = Array.prototype.slice.apply(arguments);\n\t\t\t}\n\t\t\tthis.only(_.difference(Object.keys(opts.properties), omit));\n\t\t\treturn this;\n\t\t},\n\t\tlimit: function (limit) {\n\t\t\topts.limit = limit;\n\t\t\treturn this;\n\t\t},\n\t\tskip: function (offset) {\n\t\t\treturn this.offset(offset);\n\t\t},\n\t\toffset: function (offset) {\n\t\t\topts.offset = offset;\n\t\t\treturn this;\n\t\t},\n\t\torder: function (property, order) {\n\t\t\tif (!Array.isArray(opts.order)) {\n\t\t\t\topts.order = [];\n\t\t\t}\n\t\t\tif (property[0] === \"-\") {\n\t\t\t\topts.order.push([ property.substr(1), \"Z\" ]);\n\t\t\t} else {\n\t\t\t\topts.order.push([ property, (order && order.toUpperCase() === \"Z\" ? \"Z\" : \"A\") ]);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\torderRaw: function (str, args) {\n\t\t\tif (!Array.isArray(opts.order)) {\n\t\t\t\topts.order = [];\n\t\t\t}\n\t\t\topts.order.push([ str, args || [] ]);\n\t\t\treturn this;\n\t\t},\n\t\tcount: function (cb) {\n\t\t\topts.driver.count(opts.table, prepareConditions(), {\n\t\t\t\tmerge  : opts.merge\n\t\t\t}, function (err, data) {\n\t\t\t\tif (err || data.length === 0) {\n\t\t\t\t\treturn cb(err);\n\t\t\t\t}\n\t\t\t\treturn cb(null, data[0].c);\n\t\t\t});\n\t\t\treturn this;\n\t\t},\n\t\tremove: function (cb) {\n\t\t\tvar keys = _.map(opts.keyProperties, 'mapsTo');\n\n\t\t\topts.driver.find(keys, opts.table, prepareConditions(), {\n\t\t\t\tlimit  : opts.limit,\n\t\t\t\torder  : prepareOrder(),\n\t\t\t\tmerge  : opts.merge,\n\t\t\t\toffset : opts.offset,\n\t\t\t\texists : opts.exists\n\t\t\t}, function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb(err);\n\t\t\t\t}\n\t\t\t\tif (data.length === 0) {\n\t\t\t\t\treturn cb(null);\n\t\t\t\t}\n\n\t\t\t\tvar ids = [], conditions = {};\n\t\t\t\tvar or;\n\n\t\t\t\tconditions.or = [];\n\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tor = {};\n\t\t\t\t\tfor (var j = 0; j < opts.keys.length; j++) {\n\t\t\t\t\t\tor[keys[j]] = data[i][keys[j]];\n\t\t\t\t\t}\n\t\t\t\t\tconditions.or.push(or);\n\t\t\t\t}\n\n\t\t\t\treturn opts.driver.remove(opts.table, conditions, cb);\n\t\t\t});\n\t\t\treturn this;\n\t\t},\n\t\tfirst: function (cb) {\n\t\t\treturn this.run(function (err, items) {\n\t\t\t\treturn cb(err, items && items.length > 0 ? items[0] : null);\n\t\t\t});\n\t\t},\n\t\tlast: function (cb) {\n\t\t\treturn this.run(function (err, items) {\n\t\t\t\treturn cb(err, items && items.length > 0 ? items[items.length - 1] : null);\n\t\t\t});\n\t\t},\n\t\teach: function (cb) {\n\t\t\treturn new ChainInstance(this, cb);\n\t\t},\n\t\trun: function (cb) {\n\t\t\tchainRun(cb);\n\t\t\treturn this;\n\t\t},\n\t\tsuccess: function (cb) {\n\t\t\tif (!promise) {\n\t\t\t\tpromise = new Promise();\n\t\t\t\tpromise.handle(this.all);\n\t\t\t}\n\t\t\treturn promise.success(cb);\n\t\t},\n\t\tfail: function (cb) {\n\t\t\tif (!promise) {\n\t\t\t\tpromise = new Promise();\n\t\t\t\tpromise.handle(this.all);\n\t\t\t}\n\t\t\treturn promise.fail(cb);\n\t\t},\n\t\teager: function () {\n\t\t\t// This will allow params such as (\"abc\", \"def\") or ([\"abc\", \"def\"])\n\t\t\tvar associations = _.flatten(arguments);\n\n\t\t\t// TODO: Implement eager loading for Mongo and delete this.\n\t\t\tif (opts.driver.config.protocol == \"mongodb:\") {\n\t\t\t\tthrow new Error(\"MongoDB does not currently support eager loading\");\n\t\t\t}\n\n\t\t\topts.__eager = _.filter(opts.associations, function (association) {\n\t\t\t\treturn ~associations.indexOf(association.name);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\t};\n\tchain.all = chain.where = chain.find;\n\n\tif (opts.associations) {\n\t\tfor (var i = 0; i < opts.associations.length; i++) {\n\t\t\taddChainMethod(chain, opts.associations[i], opts);\n\t\t}\n\t}\n\tfor (var k in Model) {\n\t\tif ([\n\t\t\t\"hasOne\", \"hasMany\",\n\t\t\t\"drop\", \"sync\", \"get\", \"clear\", \"create\",\n\t\t\t\"exists\", \"settings\", \"aggregate\"\n\t\t].indexOf(k) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (typeof Model[k] !== \"function\" || chain[k]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchain[k] = Model[k];\n\t}\n\tchain.model   = Model;\n\tchain.options = opts;\n\n\treturn chain;\n}\n\nfunction addChainMethod(chain, association, opts) {\n\tchain[association.hasAccessor] = function (value) {\n\t\tif (!opts.exists) {\n\t\t\topts.exists = [];\n\t\t}\n\t\tvar conditions = {};\n\n\t\tvar assocIds = Object.keys(association.mergeAssocId);\n\t\tvar ids = association.model.id;\n\t\tfunction mergeConditions(source) {\n\t\t\tfor (var i = 0; i < assocIds.length; i++) {\n\t\t\t\tif (typeof conditions[assocIds[i]] === \"undefined\") {\n\t\t\t\t\tconditions[assocIds[i]] = source[ids[i]];\n\t\t\t\t} else if (Array.isArray(conditions[assocIds[i]])) {\n\t\t\t\t\tconditions[assocIds[i]].push(source[ids[i]]);\n\t\t\t\t} else {\n\t\t\t\t\tconditions[assocIds[i]] = [ conditions[assocIds[i]], source[ids[i]] ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tmergeConditions(value[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tmergeConditions(value);\n\t\t}\n\n\t\topts.exists.push({\n\t\t\ttable      : association.mergeTable,\n\t\t\tlink       : [ Object.keys(association.mergeId), association.model.id ],\n\t\t\tconditions : conditions\n\t\t});\n\n\t\treturn chain;\n\t};\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Utilities.js":"var _ = require('lodash')\n\n/**\n * Order should be a String (with the property name assumed ascending)\n * or an Array or property String names.\n *\n * Examples:\n *\n * 1. 'property1' (ORDER BY property1 ASC)\n * 2. '-property1' (ORDER BY property1 DESC)\n * 3. [ 'property1' ] (ORDER BY property1 ASC)\n * 4. [ '-property1' ] (ORDER BY property1 DESC)\n * 5. [ 'property1', 'A' ] (ORDER BY property1 ASC)\n * 6. [ 'property1', 'Z' ] (ORDER BY property1 DESC)\n * 7. [ '-property1', 'A' ] (ORDER BY property1 ASC)\n * 8. [ 'property1', 'property2' ] (ORDER BY property1 ASC, property2 ASC)\n * 9. [ 'property1', '-property2' ] (ORDER BY property1 ASC, property2 DESC)\n * ...\n */\nexports.standardizeOrder = function (order) {\n\tif (typeof order === \"string\") {\n\t\tif (order[0] === \"-\") {\n\t\t\treturn [ [ order.substr(1), \"Z\" ] ];\n\t\t}\n\t\treturn [ [ order, \"A\" ] ];\n\t}\n\n\tvar new_order = [], minus;\n\n\tfor (var i = 0; i < order.length; i++) {\n\t\tminus = (order[i][0] === \"-\");\n\n\t\tif (i < order.length - 1 && [ \"A\", \"Z\" ].indexOf(order[i + 1].toUpperCase()) >= 0) {\n\t\t\tnew_order.push([\n\t\t\t\t(minus ? order[i].substr(1) : order[i]),\n\t\t\t\torder[i + 1]\n\t\t\t]);\n\t\t\ti += 1;\n\t\t} else if (minus) {\n\t\t\tnew_order.push([ order[i].substr(1), \"Z\" ]);\n\t\t} else {\n\t\t\tnew_order.push([ order[i], \"A\" ]);\n\t\t}\n\t}\n\n\treturn new_order;\n};\n\n/**\n * Operations\n * A) Build an index of associations, with their name as the key\n * B) Check for any conditions with a key in the association index\n * C) Ensure that our condition supports array values\n * D) Remove original condition (not DB compatible)\n * E) Convert our association fields into an array, indexes are the same as model.id\n * F) Itterate through values for the condition, only accept instances of the same type as the association\n */\nexports.checkConditions = function (conditions, one_associations) {\n\tvar k, i, j;\n\n\t// A)\n\tvar associations = {};\n\tfor (i = 0; i < one_associations.length; i++) {\n\t\tassociations[one_associations[i].name] = one_associations[i];\n\t}\n\n\tfor (k in conditions) {\n\t\t// B)\n\t\tif (!associations.hasOwnProperty(k)) continue;\n\n\t\t// C)\n\t\tvar values = conditions[k];\n\t\tif (!Array.isArray(values)) values = [values];\n\n\t\t// D)\n\t\tdelete conditions[k];\n\n\t\t// E)\n\t\tvar association_fields = Object.keys(associations[k].field);\n\t\tvar model = associations[k].model;\n\n\t\t// F)\n\t\tfor (i = 0; i < values.length; i++) {\n\t\t\tif (values[i].isInstance && values[i].model().uid === model.uid) {\n\t\t\t\tif (association_fields.length === 1) {\n\t\t\t\t\tif (typeof conditions[association_fields[0]] === 'undefined') {\n\t\t\t\t\t\tconditions[association_fields[0]] = values[i][model.id[0]];\n\t\t\t\t\t} else if(Array.isArray(conditions[association_fields[0]])) {\n\t\t\t\t\t\tconditions[association_fields[0]].push(values[i][model.id[0]]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconditions[association_fields[0]] = [conditions[association_fields[0]], values[i][model.id[0]]];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar _conds = {};\n\t\t\t\t\tfor (j = 0; j < association_fields.length; i++) {\n\t\t\t\t\t\t_conds[association_fields[j]] = values[i][model.id[j]];\n\t\t\t\t\t}\n\n\t\t\t\t\tconditions.or = conditions.or || [];\n\t\t\t\t\tconditions.or.push(_conds);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn conditions;\n};\n\n/**\n * Gets all the values within an object or array, optionally\n * using a keys array to get only specific values\n */\nexports.values = function (obj, keys) {\n\tvar i, k, vals = [];\n\n\tif (keys) {\n\t\tfor (i = 0; i < keys.length; i++) {\n\t\t\tvals.push(obj[keys[i]]);\n\t\t}\n\t} else if (Array.isArray(obj)) {\n\t\tfor (i = 0; i < obj.length; i++) {\n\t\t\tvals.push(obj[i]);\n\t\t}\n\t} else {\n\t\tfor (k in obj) {\n\t\t\tif (!/[0-9]+/.test(k)) {\n\t\t\t\tvals.push(obj[k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn vals;\n};\n\n// Qn:       is Zero a valid value for a FK column?\n// Why?      Well I've got a pre-existing database that started all its 'serial' IDs at zero...\n// Answer:   hasValues() is only used in hasOne association, so it's probably ok...\nexports.hasValues = function (obj, keys) {\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tif (!obj[keys[i]] && obj[keys[i]] !== 0) return false;  // 0 is also a good value...\n\t}\n\treturn true;\n};\n\nexports.populateConditions = function (model, fields, source, target, overwrite) {\n\tfor (var i = 0; i < model.id.length; i++) {\n\t\tif (typeof target[fields[i]] === 'undefined' || overwrite !== false) {\n\t\t\ttarget[fields[i]] = source[model.id[i]];\n\t\t} else if (Array.isArray(target[fields[i]])) {\n\t\t\ttarget[fields[i]].push(source[model.id[i]]);\n\t\t} else {\n\t\t\ttarget[fields[i]] = [target[fields[i]], source[model.id[i]]];\n\t\t}\n\t}\n};\n\nexports.getConditions = function (model, fields, from) {\n\tvar conditions = {};\n\n\texports.populateConditions(model, fields, from, conditions);\n\n\treturn conditions;\n};\n\nexports.wrapFieldObject = function (params) {\n\tif (!params.field) {\n\t\tvar assoc_key = params.model.settings.get(\"properties.association_key\");\n\n\t\tif (typeof assoc_key === \"function\") {\n\t\t    params.field = assoc_key(params.altName.toLowerCase(), params.model.id[0]);\n\t\t} else {\n\t\t\tparams.field = assoc_key.replace(\"{name}\", params.altName.toLowerCase())\n\t\t\t               .replace(\"{field}\", params.model.id[0]);\n\t\t}\n\t}\n\n\tif (typeof params.field == 'object') {\n\t\tfor (var k in params.field) {\n\t\t\tif (!/[0-9]+/.test(k) && params.field.hasOwnProperty(k)) {\n\t\t\t\treturn params.field;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar newObj = {}, newProp, propPreDefined, propFromKey;\n\n\tpropPreDefined = params.model.properties[params.field];\n\tpropFromKey    = params.model.properties[params.model.id[0]];\n\tnewProp        = { type: 'integer' };\n\n\tvar prop = _.cloneDeep(propPreDefined || propFromKey || newProp);\n\n\tif (!propPreDefined) {\n\t\t_.extend(prop, {\n\t\t\tname: params.field, mapsTo: params.mapsTo || params.field\n\t\t});\n\t}\n\n\tnewObj[params.field] = prop;\n\n\treturn newObj;\n};\n\nexports.formatField = function (model, name, required, reversed) {\n\tvar fields = {}, field_opts, field_name;\n\tvar keys = model.id;\n\tvar assoc_key = model.settings.get(\"properties.association_key\");\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tif (reversed) {\n\t\t\tfield_name = keys[i];\n\t\t} else if (typeof assoc_key === \"function\") {\n\t\t\tfield_name = assoc_key(name.toLowerCase(), keys[i]);\n\t\t} else {\n\t\t\tfield_name = assoc_key.replace(\"{name}\", name.toLowerCase())\n\t\t\t                      .replace(\"{field}\", keys[i]);\n\t\t}\n\n\t\tif (model.properties.hasOwnProperty(keys[i])) {\n\t\t\tvar p = model.properties[keys[i]];\n\n\t\t\tfield_opts = {\n\t\t\t\ttype     : p.type || \"integer\",\n\t\t\t\tsize     : p.size || 4,\n\t\t\t\tunsigned : p.unsigned || true,\n\t\t\t\ttime     : p.time || false,\n\t\t\t\tbig      : p.big || false,\n\t\t\t\tvalues   : p.values || null,\n\t\t\t\trequired : required,\n\t\t\t\tname     : field_name,\n\t\t\t\tmapsTo   : field_name\n\t\t\t};\n\t\t} else {\n\t\t\tfield_opts = {\n\t\t\t\ttype     : \"integer\",\n\t\t\t\tunsigned : true,\n\t\t\t\tsize     : 4,\n\t\t\t\trequired : required,\n\t\t\t\tname     : field_name,\n\t\t\t\tmapsTo   : field_name\n\t\t\t};\n\t\t}\n\n\t\tfields[field_name] = field_opts;\n\t}\n\n\treturn fields;\n};\n\n// If the parent associations key is `serial`, the join tables\n// key should be changed to `integer`.\nexports.convertPropToJoinKeyProp = function (props, opts) {\n\tvar prop;\n\n\tfor (var k in props) {\n\t\tprop = props[k];\n\n\t\tprop.required = opts.required;\n\n\t\tif (prop.type == 'serial') {\n\t\t\tprop.type = 'integer';\n\t\t}\n\t\tif (opts.makeKey) {\n\t\t\tprop.key = true;\n\t\t} else {\n\t\t\tdelete prop.key;\n\t\t}\n\t}\n\n\treturn props;\n}\n\nexports.getRealPath = function (path_str, stack_index) {\n\tvar path = require(\"path\"); // for now, load here (only when needed)\n\tvar cwd = process.cwd();\n\tvar err = new Error();\n\tvar tmp = err.stack.split(/\\r?\\n/)[typeof stack_index !== \"undefined\" ? stack_index : 3], m;\n\n\tif ((m = tmp.match(/^\\s*at\\s+(.+):\\d+:\\d+$/)) !== null) {\n\t\tcwd = path.dirname(m[1]);\n\t} else if ((m = tmp.match(/^\\s*at\\s+module\\.exports\\s+\\((.+?)\\)/)) !== null) {\n\t\tcwd = path.dirname(m[1]);\n\t} else if ((m = tmp.match(/^\\s*at\\s+.+\\s+\\((.+):\\d+:\\d+\\)$/)) !== null) {\n\t\tcwd = path.dirname(m[1]);\n\t}\n\tvar pathIsAbsolute = path.isAbsolute || require('path-is-absolute');\n\tif (!pathIsAbsolute(path_str)) {\n\t\tpath_str = path.join(cwd, path_str);\n\t}\n\tif (path_str.substr(-1) === path.sep) {\n\t\tpath_str += \"index\";\n\t}\n\n\treturn path_str;\n};\n\nexports.transformPropertyNames = function (dataIn, properties) {\n\tvar k, prop;\n\tvar dataOut = {};\n\n\tfor (k in dataIn) {\n\t\tprop = properties[k];\n\t\tif (prop) {\n\t\t\tdataOut[prop.mapsTo] = dataIn[k];\n\t\t} else {\n\t\t\tdataOut[k] = dataIn[k];\n\t\t}\n\t}\n\treturn dataOut;\n};\n\nexports.transformOrderPropertyNames = function (order, properties) {\n\tif (!order) return order;\n\n\tvar i, item;\n\tvar newOrder = JSON.parse(JSON.stringify(order));\n\n\t// Rename order properties according to mapsTo\n\tfor (var i = 0; i < newOrder.length; i++) {\n\t\titem = newOrder[i];\n\n\t\t// orderRaw\n\t\tif (Array.isArray(item[1])) continue;\n\n\t\tif (Array.isArray(item[0])) {\n\t\t\t// order on a hasMany\n\t\t\t// [ ['modelName', 'propName'], 'Z']\n\t\t\titem[0][1] = properties[item[0][1]].mapsTo;\n\t\t} else {\n\t\t\t// normal order\n\t\t\titem[0] = properties[item[0]].mapsTo;\n\t\t}\n\t}\n\treturn newOrder;\n}\n\nexports.renameDatastoreFieldsToPropertyNames = function (data, fieldToPropertyMap) {\n\tvar k, prop;\n\n\tfor (k in data) {\n\t\tprop = fieldToPropertyMap[k];\n\t\tif (prop && prop.name != k) {\n\t\t\tdata[prop.name] = data[k];\n\t\t\tdelete data[k];\n\t\t}\n\t}\n\treturn data;\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/ChainInstance.js":"module.exports = ChainInstance;\n\nfunction ChainInstance(chain, cb) {\n\tvar instances = null;\n\tvar loading   = false;\n\tvar queue     = [];\n\n\tvar load = function () {\n\t\tloading = true;\n\t\tchain.run(function (err, items) {\n\t\t\tinstances = items;\n\n\t\t\treturn next();\n\t\t});\n\t};\n\tvar promise = function(hwd, next) {\n\t\treturn function () {\n\t\t\tif (!loading) {\n\t\t\t\tload();\n\t\t\t}\n\n\t\t\tqueue.push({ hwd: hwd, args: arguments });\n\n\t\t\treturn calls;\n\t\t};\n\t};\n\tvar next = function () {\n\t\tif (queue.length === 0) return;\n\n\t\tvar item = queue.shift();\n\n\t\titem.hwd.apply(calls, item.args);\n\t};\n\tvar calls = {\n\t\tfilter: promise(function (cb) {\n\t\t\tinstances = instances.filter(cb);\n\n\t\t\treturn next();\n\t\t}),\n\t\tforEach: promise(function (cb) {\n\t\t\tinstances.forEach(cb);\n\n\t\t\treturn next();\n\t\t}),\n\t\tsort: promise(function (cb) {\n\t\t\tinstances.sort(cb);\n\n\t\t\treturn next();\n\t\t}),\n\t\tcount: promise(function (cb) {\n\t\t\tcb(instances.length);\n\n\t\t\treturn next();\n\t\t}),\n\t\tget: promise(function (cb) {\n\t\t\tcb(instances);\n\n\t\t\treturn next();\n\t\t}),\n\t\tsave: promise(function (cb) {\n\t\t\tvar saveNext = function (i) {\n\t\t\t\tif (i >= instances.length) {\n\t\t\t\t\tif (typeof cb === \"function\") {\n\t\t\t\t\t\tcb();\n\t\t\t\t\t}\n\t\t\t\t\treturn next();\n\t\t\t\t}\n\n\t\t\t\treturn instances[i].save(function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (typeof cb === \"function\") {\n\t\t\t\t\t\t\tcb(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn next();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn saveNext(i + 1);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn saveNext(0);\n\t\t})\n\t};\n\n\tif (typeof cb === \"function\") {\n\t\treturn calls.forEach(cb);\n\t}\n\treturn calls;\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Promise.js":"exports.Promise = Promise;\n\nfunction Promise(opts) {\n\topts = opts || {};\n\n\tvar success_cb = opts.success || null;\n\tvar fail_cb    = opts.fail    || null;\n\n\treturn {\n\t\thandle: function (promise) {\n\t\t\tpromise(function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (fail_cb) fail_cb(err);\n\t\t\t\t} else {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\t\t\t\t\tif (success_cb) success_cb.apply(null, args);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tsuccess: function (cb) {\n\t\t\tsuccess_cb = cb;\n\t\t\treturn this;\n\t\t},\n\t\tfail: function (cb) {\n\t\t\tfail_cb = cb;\n\t\t\treturn this;\n\t\t}\n\t};\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Instance.js":"var Utilities = require(\"./Utilities\");\nvar Property  = require(\"./Property\");\nvar Hook      = require(\"./Hook\");\nvar enforce   = require(\"enforce\");\n\nexports.Instance = Instance;\n\nfunction Instance(Model, opts) {\n\topts = opts || {};\n\topts.data = opts.data || {};\n\topts.extra = opts.extra || {};\n\topts.keys = opts.keys || \"id\";\n\topts.changes = (opts.is_new ? Object.keys(opts.data) : []);\n\topts.extrachanges = [];\n\topts.associations = {};\n\topts.originalKeyValues = {};\n\n\tvar instance_saving = false;\n\tvar events = {};\n\tvar instance = {};\n\tvar emitEvent = function () {\n\t\tvar args = Array.prototype.slice.apply(arguments);\n\t\tvar event = args.shift();\n\n\t\tif (!events.hasOwnProperty(event)) return;\n\n\t\tevents[event].map(function (cb) {\n\t\t\tcb.apply(instance, args);\n\t\t});\n\t};\n\tvar rememberKeys = function () {\n\t\tvar i, prop;\n\n\t\tfor(i = 0; i < opts.keyProperties.length; i++) {\n\t\t\tprop = opts.keyProperties[i];\n\t\t\topts.originalKeyValues[prop.name] = opts.data[prop.name];\n\t\t}\n\t};\n\tvar shouldSaveAssocs = function (saveOptions) {\n\t\tif (Model.settings.get(\"instance.saveAssociationsByDefault\")) {\n\t\t\treturn saveOptions.saveAssociations !== false;\n\t\t} else {\n\t\t\treturn !!saveOptions.saveAssociations;\n\t\t}\n\t};\n\tvar handleValidations = function (cb) {\n\t\tvar pending = [], errors = [], required, alwaysValidate;\n\n\t\tHook.wait(instance, opts.hooks.beforeValidation, function (err) {\n\t\t    var k, i;\n\t\t\tif (err) {\n\t\t\t\treturn saveError(cb, err);\n\t\t\t}\n\n\t\t\tvar checks = new enforce.Enforce({\n\t\t\t\treturnAllErrors : Model.settings.get(\"instance.returnAllErrors\")\n\t\t\t});\n\n\t\t\tfor (k in opts.validations) {\n\t\t\t\trequired = false;\n\n\t\t\t\tif (Model.allProperties[k]) {\n\t\t\t\t\trequired = Model.allProperties[k].required;\n\t\t\t\t\talwaysValidate = Model.allProperties[k].alwaysValidate;\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < opts.one_associations.length; i++) {\n\t\t\t\t\t\tif (opts.one_associations[i].field === k) {\n\t\t\t\t\t\t\trequired = opts.one_associations[i].required;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!alwaysValidate && !required && instance[k] == null) {\n\t\t\t\t\tcontinue; // avoid validating if property is not required and is \"empty\"\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < opts.validations[k].length; i++) {\n\t\t\t\t\tchecks.add(k, opts.validations[k][i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchecks.context(\"instance\", instance);\n\t\t\tchecks.context(\"model\", Model);\n\t\t\tchecks.context(\"driver\", opts.driver);\n\n\t\t\treturn checks.check(instance, cb);\n\t\t});\n\t};\n\tvar saveError = function (cb, err) {\n\t\tinstance_saving = false;\n\n\t\temitEvent(\"save\", err, instance);\n\n\t\tHook.trigger(instance, opts.hooks.afterSave, false);\n\n\t\tif (typeof cb === \"function\") {\n\t\t\tcb(err, instance);\n\t\t}\n\t};\n\tvar saveInstance = function (saveOptions, cb) {\n\t\t// what this condition means:\n\t\t// - If the instance is in state mode\n\t\t// - AND it's not an association that is asking it to save\n\t\t//   -> return has already saved\n\t\tif (instance_saving && saveOptions.saveAssociations !== false) {\n\t\t\treturn cb(null, instance);\n\t\t}\n\t\tinstance_saving = true;\n\n\t\thandleValidations(function (err) {\n\t\t\tif (err) {\n\t\t\t\treturn saveError(cb, err);\n\t\t\t}\n\n\t\t\tif (opts.is_new) {\n\t\t\t\twaitHooks([ \"beforeCreate\", \"beforeSave\" ], function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn saveError(cb, err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn saveNew(saveOptions, getInstanceData(), cb);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\twaitHooks([ \"beforeSave\" ], function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn saveError(cb, err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn savePersisted(saveOptions, getInstanceData(), cb);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\tvar runAfterSaveActions = function (cb, create, err) {\n\t\tinstance_saving = false;\n\n\t\temitEvent(\"save\", err, instance);\n\n\t\tif (create) {\n\t\t\tHook.trigger(instance, opts.hooks.afterCreate, !err);\n\t\t}\n\t\tHook.trigger(instance, opts.hooks.afterSave, !err);\n\n\t\tcb();\n\t};\n\tvar getInstanceData = function () {\n\t\tvar data = {}, prop;\n\t\tfor (var k in opts.data) {\n\t\t\tif (!opts.data.hasOwnProperty(k)) continue;\n\t\t\tprop = Model.allProperties[k];\n\n\t\t\tif (prop) {\n\t\t\t\tif (opts.data[k] == null &&  (prop.type == 'serial' || typeof prop.defaultValue == 'function')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (opts.driver.propertyToValue) {\n\t\t\t\t\tdata[k] = opts.driver.propertyToValue(opts.data[k], prop);\n\t\t\t\t} else {\n\t\t\t\t\tdata[k] = opts.data[k];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata[k] = opts.data[k];\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t};\n\tvar waitHooks = function (hooks, next) {\n\t\tvar nextHook = function () {\n\t\t\tif (hooks.length === 0) {\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\tHook.wait(instance, opts.hooks[hooks.shift()], function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn next(err);\n\t\t\t\t}\n\n\t\t\t\treturn nextHook();\n\t\t\t});\n\t\t};\n\n\t\treturn nextHook();\n\t};\n\tvar saveNew = function (saveOptions, data, cb) {\n\t\tvar i, prop;\n\n\t\tvar finish = function (err) {\n\t\t\trunAfterSaveActions(function () {\n\t\t\t\tif (err) return cb(err);\n\t\t\t\tsaveInstanceExtra(cb);\n\t\t\t}, true);\n\t\t}\n\n\t\tdata = Utilities.transformPropertyNames(data, Model.allProperties);\n\n\t\topts.driver.insert(opts.table, data, opts.keyProperties, function (save_err, info) {\n\t\t\tif (save_err) {\n\t\t\t\treturn saveError(cb, save_err);\n\t\t\t}\n\n\t\t\topts.changes.length = 0;\n\n\t\t\tfor (i = 0; i < opts.keyProperties.length; i++) {\n\t\t\t\tprop = opts.keyProperties[i];\n\t\t\t\topts.data[prop.name] = info.hasOwnProperty(prop.name) ? info[prop.name] : data[prop.name];\n\t\t\t}\n\t\t\topts.is_new = false;\n\t\t\trememberKeys();\n\n\t\t\tif (!shouldSaveAssocs(saveOptions)) {\n\t\t\t\treturn finish();\n\t\t\t}\n\n\t\t\treturn saveAssociations(finish);\n\t\t});\n\t};\n\tvar savePersisted = function (saveOptions, data, cb) {\n\t\tvar changes = {}, conditions = {}, i, prop;\n\n\t\tvar next = function (saved) {\n\t\t\tvar finish = function () {\n\t\t\t\tsaveInstanceExtra(cb);\n\t\t\t}\n\n\t\t\tif(!saved && !shouldSaveAssocs(saveOptions)) {\n\t\t\t\tfinish();\n\t\t\t} else {\n\t\t\t\tif (!shouldSaveAssocs(saveOptions)) {\n\t\t\t\t\trunAfterSaveActions(function () {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t}, false);\n\t\t\t\t} else {\n\t\t\t\t\tsaveAssociations(function (err, assocSaved) {\n\t\t\t\t\t\tif (saved || assocSaved) {\n\t\t\t\t\t\t\trunAfterSaveActions(function () {\n\t\t\t\t\t\t\t\tif (err) return cb(err);\n\t\t\t\t\t\t\t\tfinish();\n\t\t\t\t\t\t\t}, false, err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinish();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (opts.changes.length === 0) {\n\t\t\tnext(false);\n\t\t} else {\n\t\t\tfor (i = 0; i < opts.changes.length; i++) {\n\t\t\t\tchanges[opts.changes[i]] = data[opts.changes[i]];\n\t\t\t}\n\t\t\tfor (i = 0; i < opts.keyProperties.length; i++) {\n\t\t\t\tprop = opts.keyProperties[i];\n\t\t\t\tconditions[prop.mapsTo] = opts.originalKeyValues[prop.name];\n\t\t\t}\n\t\t\tchanges = Utilities.transformPropertyNames(changes, Model.allProperties);\n\n\t\t\topts.driver.update(opts.table, changes, conditions, function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn saveError(cb, err);\n\t\t\t\t}\n\t\t\t\topts.changes.length = 0;\n\t\t\t\trememberKeys();\n\n\t\t\t\tnext(true);\n\t\t\t});\n\t\t}\n\t};\n\tvar saveAssociations = function (cb) {\n\t\tvar pending = 1, errored = false, i, j;\n\t\tvar saveAssociation = function (accessor, instances) {\n\t\t\tpending += 1;\n\n\t\t\tinstance[accessor](instances, function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (errored) return;\n\n\t\t\t\t\terrored = true;\n\t\t\t\t\treturn cb(err, true);\n\t\t\t\t}\n\n\t\t\t\tif (--pending === 0) {\n\t\t\t\t\treturn cb(null, true);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tvar _saveOneAssociation = function (assoc) {\n\t\t\tif (!instance[assoc.name] || typeof instance[assoc.name] !== \"object\") return;\n\t\t\tif (assoc.reversed) {\n\t\t\t\t// reversed hasOne associations should behave like hasMany\n\t\t\t\tif (!Array.isArray(instance[assoc.name])) {\n\t\t\t\t\tinstance[assoc.name] = [ instance[assoc.name] ];\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < instance[assoc.name].length; i++) {\n\t\t\t\t\tif (!instance[assoc.name][i].isInstance) {\n\t\t\t\t\t\tinstance[assoc.name][i] = new assoc.model(instance[assoc.name][i]);\n\t\t\t\t\t}\n\t\t\t\t\tsaveAssociation(assoc.setAccessor, instance[assoc.name][i]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!instance[assoc.name].isInstance) {\n\t\t\t  instance[assoc.name] = new assoc.model(instance[assoc.name]);\n\t\t\t}\n\n\t\t\tsaveAssociation(assoc.setAccessor, instance[assoc.name]);\n\t\t};\n\n\t\tfor (i = 0; i < opts.one_associations.length; i++) {\n\t\t\t_saveOneAssociation(opts.one_associations[i]);\n\t\t}\n\n\n\t\tvar _saveManyAssociation = function (assoc) {\n\t\t\tvar assocVal = instance[assoc.name];\n\n\t\t\tif (!Array.isArray(assocVal)) return;\n\t\t\tif (!opts.associations[assoc.name].changed) return;\n\n\t\t\tfor (j = 0; j < assocVal.length; j++) {\n\t\t\t\tif (!assocVal[j].isInstance) {\n\t\t\t\t\tassocVal[j] = new assoc.model(assocVal[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsaveAssociation(assoc.setAccessor, assocVal);\n\t\t};\n\n\t\tfor (i = 0; i < opts.many_associations.length; i++) {\n\t\t\t_saveManyAssociation(opts.many_associations[i]);\n\t\t}\n\n\t\tif (--pending === 0) {\n\t\t\treturn cb(null, false);\n\t\t}\n\t};\n\tvar saveInstanceExtra = function (cb) {\n\t\tif (opts.extrachanges.length === 0) {\n\t\t\tif (cb) return cb(null, instance);\n\t\t\telse return;\n\t\t}\n\n\t\tvar data = {};\n\t\tvar conditions = {};\n\n\t\tfor (var i = 0; i < opts.extrachanges.length; i++) {\n\t\t\tif (!opts.data.hasOwnProperty(opts.extrachanges[i])) continue;\n\n\t\t\tif (opts.extra[opts.extrachanges[i]]) {\n\t\t\t\tdata[opts.extrachanges[i]] = opts.data[opts.extrachanges[i]];\n\t\t\t\tif (opts.driver.propertyToValue) {\n\t\t\t\t\tdata[opts.extrachanges[i]] = opts.driver.propertyToValue(data[opts.extrachanges[i]], opts.extra[opts.extrachanges[i]]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata[opts.extrachanges[i]] = opts.data[opts.extrachanges[i]];\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < opts.extra_info.id.length; i++) {\n\t\t\tconditions[opts.extra_info.id_prop[i]] = opts.extra_info.id[i];\n\t\t\tconditions[opts.extra_info.assoc_prop[i]] = opts.data[opts.keys[i]];\n\t\t}\n\n\t\topts.driver.update(opts.extra_info.table, data, conditions, function (err) {\n\t\t\treturn cb(err);\n\t\t});\n\t};\n\tvar removeInstance = function (cb) {\n\t\tif (opts.is_new) {\n\t\t\treturn cb(null);\n\t\t}\n\n\t\tvar conditions = {};\n\t\tfor (var i = 0; i < opts.keys.length; i++) {\n\t\t    conditions[opts.keys[i]] = opts.data[opts.keys[i]];\n\t\t}\n\n\t\tHook.wait(instance, opts.hooks.beforeRemove, function (err) {\n\t\t\tif (err) {\n\t\t\t\temitEvent(\"remove\", err, instance);\n\t\t\t\tif (typeof cb === \"function\") {\n\t\t\t\t\tcb(err, instance);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\temitEvent(\"beforeRemove\", instance);\n\n\t\t\topts.driver.remove(opts.table, conditions, function (err, data) {\n\t\t\t\tHook.trigger(instance, opts.hooks.afterRemove, !err);\n\n\t\t\t\temitEvent(\"remove\", err, instance);\n\n\t\t\t\tif (typeof cb === \"function\") {\n\t\t\t\t\tcb(err, instance);\n\t\t\t\t}\n\n\t\t\t\tinstance = undefined;\n\t\t\t});\n\t\t});\n\t};\n\tvar saveInstanceProperty = function (key, value) {\n\t\tvar changes = {}, conditions = {};\n\t\tchanges[key] = value;\n\n\t\tif (Model.properties[key]) {\n\t\t\tif (opts.driver.propertyToValue) {\n\t\t\t\tchanges[key] = opts.driver.propertyToValue(changes[key], Model.properties[key]);\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < opts.keys.length; i++) {\n\t\t\tconditions[opts.keys[i]] = opts.data[opts.keys[i]];\n\t\t}\n\n\t\tHook.wait(instance, opts.hooks.beforeSave, function (err) {\n\t\t\tif (err) {\n\t\t\t\tHook.trigger(instance, opts.hooks.afterSave, false);\n\t\t\t\temitEvent(\"save\", err, instance);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\topts.driver.update(opts.table, changes, conditions, function (err) {\n\t\t\t\tif (!err) {\n\t\t\t\t\topts.data[key] = value;\n\t\t\t\t}\n\t\t\t\tHook.trigger(instance, opts.hooks.afterSave, !err);\n\t\t\t\temitEvent(\"save\", err, instance);\n\t\t\t});\n\t\t});\n\t};\n\tvar setInstanceProperty = function (key, value) {\n\t\tvar prop = Model.allProperties[key] || opts.extra[key];\n\n\t\tif (prop) {\n\t\t\tif ('valueToProperty' in opts.driver) {\n\t\t\t\tvalue = opts.driver.valueToProperty(value, prop);\n\t\t\t}\n\t\t\tif (opts.data[key] !== value) {\n\t\t\t\topts.data[key] = value;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// ('data.a.b', 5) => opts.data.a.b = 5\n\tvar setPropertyByPath = function (path, value) {\n\t\tif (typeof path == 'string') {\n\t\t\tpath = path.split('.');\n\t\t} else if (!Array.isArray(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar propName = path.shift();\n\t\tvar prop = Model.allProperties[propName] || opts.extra[propName];\n\t\tvar currKey, currObj;\n\n\t\tif (!prop) {\n\t\t\treturn;\n\t\t}\n\t\tif (path.length == 0) {\n\t\t\tinstance[propName] = value;\n\t\t\treturn;\n\t\t}\n\t\tcurrObj = instance[propName];\n\n\t\twhile(currObj && path.length > 0 ) {\n\t\t\tcurrKey = path.shift();\n\n\t\t\tif (path.length > 0) {\n\t\t\t\tcurrObj = currObj[currKey];\n\t\t\t} else if (currObj[currKey] !== value) {\n\t\t\t\tcurrObj[currKey] = value;\n\t\t\t\topts.changes.push(propName);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar addInstanceProperty = function (key) {\n\t\tvar defaultValue = null;\n\t\tvar prop = Model.allProperties[key];\n\n\t\t// This code was first added, and then commented out in a later commit.\n\t\t// Its presence doesn't affect tests, so I'm just gonna log if it ever gets called.\n\t\t// If someone complains about noise, we know it does something, and figure it out then.\n\t\tif (instance.hasOwnProperty(key)) console.log(\"Overwriting instance property\");\n\n\t\tif (key in opts.data) {\n\t\t\tdefaultValue = opts.data[key];\n\t\t} else if (prop && 'defaultValue' in prop) {\n\t\t\tdefaultValue = prop.defaultValue;\n\t\t}\n\n\t\tsetInstanceProperty(key, defaultValue);\n\n\t\tObject.defineProperty(instance, key, {\n\t\t\tget: function () {\n\t\t\t\treturn opts.data[key];\n\t\t\t},\n\t\t\tset: function (val) {\n\t\t\t\tif (prop.key === true) {\n\t\t\t\t\tif (prop.type == 'serial' && opts.data[key] != null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topts.originalKeyValues[prop.name] = opts.data[prop.name];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!setInstanceProperty(key, val)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (opts.autoSave) {\n\t\t\t\t\tsaveInstanceProperty(key, val);\n\t\t\t\t} else if (opts.changes.indexOf(key) === -1) {\n\t\t\t\t\topts.changes.push(key);\n\t\t\t\t}\n\t\t\t},\n\t\t\tenumerable: !(prop && !prop.enumerable)\n\t\t});\n\t};\n\tvar addInstanceExtraProperty = function (key) {\n\t\tif (!instance.hasOwnProperty(\"extra\")) {\n\t\t\tinstance.extra = {};\n\t\t}\n\t\tObject.defineProperty(instance.extra, key, {\n\t\t\tget: function () {\n\t\t\t\treturn opts.data[key];\n\t\t\t},\n\t\t\tset: function (val) {\n\t\t\t\tsetInstanceProperty(key, val);\n\n\t\t\t\t/*if (opts.autoSave) {\n\t\t\t\t\tsaveInstanceProperty(key, val);\n\t\t\t\t}*/if (opts.extrachanges.indexOf(key) === -1) {\n\t\t\t\t\topts.extrachanges.push(key);\n\t\t\t\t}\n\t\t\t},\n\t\t\tenumerable: true\n\t\t});\n\t};\n\n\tvar i, k;\n\n\tfor (k in Model.allProperties) {\n\t\taddInstanceProperty(k);\n\t}\n\tfor (k in opts.extra) {\n\t\taddInstanceProperty(k);\n\t}\n\n\tfor (k in opts.methods) {\n\t\tObject.defineProperty(instance, k, {\n\t\t\tvalue      : opts.methods[k].bind(instance),\n\t\t\tenumerable : false,\n\t\t\twritable  : true\n\t\t});\n\t}\n\n\tfor (k in opts.extra) {\n\t\taddInstanceExtraProperty(k);\n\t}\n\n\tObject.defineProperty(instance, \"on\", {\n\t\tvalue: function (event, cb) {\n\t\t\tif (!events.hasOwnProperty(event)) {\n\t\t\t\tevents[event] = [];\n\t\t\t}\n\t\t\tevents[event].push(cb);\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(instance, \"save\", {\n\t\tvalue: function () {\n\t\t\tvar arg = null, objCount = 0;\n\t\t\tvar data = {}, saveOptions = {}, cb = null;\n\n\t\t\twhile (arguments.length > 0) {\n\t\t\t\targ = Array.prototype.shift.call(arguments);\n\n\t\t\t\tswitch (typeof arg) {\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tswitch (objCount) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tdata = arg;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tsaveOptions = arg;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobjCount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'function':\n\t\t\t\t\t\tcb = arg;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t    var err = new Error(\"Unknown parameter type '\" + (typeof arg) + \"' in Instance.save()\");\n\t\t\t\t\t    err.model = Model.table;\n\t\t\t\t\t    throw err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var k in data) {\n\t\t\t\tif (data.hasOwnProperty(k)) {\n\t\t\t\t\tthis[k] = data[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsaveInstance(saveOptions, function (err) {\n\t\t\t\tif (!cb) return;\n\t\t\t\tif (err) return cb(err);\n\n\t\t\t\treturn cb(null, instance);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(instance, \"saved\", {\n\t\tvalue: function () {\n\t\t\treturn opts.changes.length === 0;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(instance, \"remove\", {\n\t\tvalue: function (cb) {\n\t\t\tremoveInstance(cb);\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(instance, \"set\", {\n\t\tvalue: setPropertyByPath,\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(instance, \"markAsDirty\", {\n\t\tvalue: function (propName) {\n\t\t\tif (propName != undefined) {\n\t\t\t\topts.changes.push(propName);\n\t\t\t}\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(instance, \"dirtyProperties\", {\n\t\tget: function () { return opts.changes; },\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(instance, \"isInstance\", {\n\t\tvalue: true,\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(instance, \"isPersisted\", {\n\t\tvalue: function () {\n\t\t\treturn !opts.is_new;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(instance, \"isShell\", {\n\t\tvalue: function () {\n\t\t\treturn opts.isShell;\n\t\t},\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(instance, \"validate\", {\n\t\tvalue: function (cb) {\n\t\t\thandleValidations(function (errors) {\n\t\t\t\tcb(null, errors || false);\n\t\t\t});\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(instance, \"__singleton_uid\", {\n\t\tvalue: function (cb) {\n\t\t\treturn opts.uid;\n\t\t},\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(instance, \"__opts\", {\n\t\tvalue: opts,\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(instance, \"model\", {\n\t\tvalue: function (cb) {\n\t\t\treturn Model;\n\t\t},\n\t\tenumerable: false\n\t});\n\n\tfor (i = 0; i < opts.keyProperties.length; i++) {\n\t\tvar prop = opts.keyProperties[i];\n\n\t\tif (!(prop.name in opts.data)) {\n\t\t\topts.changes = Object.keys(opts.data);\n\t\t\tbreak;\n\t\t}\n\t}\n\trememberKeys();\n\n\topts.setupAssociations(instance);\n\n\tfor (i = 0; i < opts.one_associations.length; i++) {\n\t\tvar asc = opts.one_associations[i];\n\n\t\tif (!asc.reversed && !asc.extension) {\n\t\t\tfor (k in asc.field) {\n\t\t\t\tif (!opts.data.hasOwnProperty(k)) {\n\t\t\t\t\taddInstanceProperty(k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (asc.name in opts.data) {\n\t\t\tvar d = opts.data[asc.name];\n\t\t\tvar mapper = function (obj) {\n\t\t\t\treturn obj.isInstance ? obj : new asc.model(obj);\n\t\t\t};\n\n\t\t\tif (Array.isArray(d)) {\n\t\t\t\tinstance[asc.name] = d.map(mapper);\n\t\t\t} else {\n\t\t\t\tinstance[asc.name] = mapper(d);\n\t\t\t}\n\t\t\tdelete opts.data[asc.name];\n\t\t}\n\t}\n\tfor (i = 0; i < opts.many_associations.length; i++) {\n\t\tvar aName = opts.many_associations[i].name;\n\t\topts.associations[aName] = {\n\t\t\tchanged: false, data: opts.many_associations[i]\n\t\t};\n\n\t\tif (Array.isArray(opts.data[aName])) {\n\t\t\tinstance[aName] = opts.data[aName];\n\t\t\tdelete opts.data[aName];\n\t\t}\n\t}\n\n\tHook.wait(instance, opts.hooks.afterLoad, function (err) {\n\t\tprocess.nextTick(function () {\n\t\t\temitEvent(\"ready\", err);\n\t\t});\n\t});\n\n\treturn instance;\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Property.js":"var _        = require('lodash');\nvar ORMError = require(\"./Error\");\n\nvar KNOWN_TYPES = [\n\t\"text\",   \"number\", \"integer\", \"boolean\", \"date\", \"enum\", \"object\",\n\t\"binary\", \"point\",  \"serial\"\n];\n\nexports.normalize = function (opts) {\n\tif (typeof opts.prop === \"function\") {\n\t\tswitch (opts.prop.name) {\n\t\t\tcase \"String\":\n\t\t\t\topts.prop = { type: \"text\" };\n\t\t\t\tbreak;\n\t\t\tcase \"Number\":\n\t\t\t\topts.prop = { type: \"number\" };\n\t\t\t\tbreak;\n\t\t\tcase \"Boolean\":\n\t\t\t\topts.prop = { type: \"boolean\" };\n\t\t\t\tbreak;\n\t\t\tcase \"Date\":\n\t\t\t\topts.prop = { type: \"date\" };\n\t\t\t\tbreak;\n\t\t\tcase \"Object\":\n\t\t\t\topts.prop = { type: \"object\" };\n\t\t\t\tbreak;\n\t\t\tcase \"Buffer\":\n\t\t\t\topts.prop = { type: \"binary\" };\n\t\t\t\tbreak;\n\t\t}\n\t} else if (typeof opts.prop === \"string\") {\n\t\tvar tmp = opts.prop;\n\t\topts.prop = {};\n\t\topts.prop.type = tmp;\n\t} else if (Array.isArray(opts.prop)) {\n\t\topts.prop = { type: \"enum\", values: opts.prop };\n\t} else {\n\t\topts.prop = _.cloneDeep(opts.prop);\n\t}\n\n\tif (KNOWN_TYPES.indexOf(opts.prop.type) === -1 && !(opts.prop.type in opts.customTypes)) {\n\t\tthrow new ORMError(\"Unknown property type: \" + opts.prop.type, 'NO_SUPPORT');\n\t}\n\n\tif (!opts.prop.hasOwnProperty(\"required\") && opts.settings.get(\"properties.required\")) {\n\t\topts.prop.required = true;\n\t}\n\n\t// Defaults to true. Setting to false hides properties from JSON.stringify(modelInstance).\n\tif (!opts.prop.hasOwnProperty(\"enumerable\") || opts.prop.enumerable === true) {\n\t\topts.prop.enumerable = true;\n\t}\n\n\t// Defaults to true. Rational means floating point here.\n\tif (opts.prop.type == \"number\" && opts.prop.rational === undefined) {\n\t\topts.prop.rational = true;\n\t}\n\n\tif (!('mapsTo' in opts.prop)) {\n\t\topts.prop.mapsTo = opts.name\n\t}\n\n\tif (opts.prop.type == \"number\" && opts.prop.rational === false) {\n\t\topts.prop.type = \"integer\";\n\t\tdelete opts.prop.rational;\n\t}\n\n\topts.prop.name = opts.name;\n\n\treturn opts.prop;\n};\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Error.js":"var codes = {\n  QUERY_ERROR      : 1,\n  NOT_FOUND        : 2,\n  NOT_DEFINED      : 3,\n  NO_SUPPORT       : 4,\n  MISSING_CALLBACK : 5,\n  PARAM_MISMATCH   : 6,\n  CONNECTION_LOST  : 10,\n  BAD_MODEL        : 15\n};\n\nfunction ORMError(message, code, extras) {\n  Error.call(this);\n  Error.captureStackTrace(this, this.constructor);\n\n  this.message = message;\n  if (code) {\n  \tthis.code = codes[code];\n    this.literalCode = code;\n    if (!this.code) {\n  \t\tthrow new Error(\"Invalid error code: \" +  code);\n  \t}\n  }\n  if (extras) {\n  \tfor(var k in extras) {\n  \t\tthis[k] = extras[k];\n  \t}\n  }\n}\n\nORMError.prototype = Object.create(Error.prototype);\nORMError.prototype.constructor = ORMError;\nORMError.prototype.name        = 'ORMError';\nORMError.prototype.toString    = function () {\n  return '[ORMError ' + this.literalCode + ': ' + this.message + ']';\n}\n\nORMError.codes = codes;\n\nmodule.exports = ORMError;\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Hook.js":"exports.trigger = function () {\n\tvar args = Array.prototype.slice.apply(arguments);\n\tvar self = args.shift();\n\tvar cb   = args.shift();\n\n\tif (typeof cb === \"function\") {\n\t\tcb.apply(self, args);\n\t}\n};\n\nexports.wait = function () {\n\tvar args = Array.prototype.slice.apply(arguments);\n\tvar self = args.shift();\n\tvar cb   = args.shift();\n\tvar next = args.shift();\n\n\targs.push(next);\n\n\tif (typeof cb === \"function\") {\n\t\tcb.apply(self, args);\n\n\t\tif (cb.length < args.length) {\n\t\t\treturn next();\n\t\t}\n\t} else {\n\t\treturn next();\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/LazyLoad.js":"exports.extend = function (Instance, Model, properties) {\n\tfor (var k in properties) {\n\t\tif (properties[k].lazyload === true) {\n\t\t\taddLazyLoadProperty(properties[k].lazyname || k, Instance, Model, k);\n\t\t}\n\t}\n};\n\nfunction addLazyLoadProperty(name, Instance, Model, property) {\n\tvar method = ucfirst(name);\n\n\tObject.defineProperty(Instance, \"get\" + method, {\n\t\tvalue: function (cb) {\n\t\t\tvar conditions = {};\n\t\t\tconditions[Model.id] = Instance[Model.id];\n\n\t\t\tModel.find(conditions, { identityCache: false }).only(Model.id.concat(property)).first(function (err, item) {\n\t\t\t\treturn cb(err, item ? item[property] : null);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(Instance, \"remove\" + method, {\n\t\tvalue: function (cb) {\n\t\t\tvar conditions = {};\n\t\t\tconditions[Model.id] = Instance[Model.id];\n\n\t\t\tModel.find(conditions, { identityCache: false }).only(Model.id.concat(property)).first(function (err, item) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb(err);\n\t\t\t\t}\n\t\t\t\tif (!item) {\n\t\t\t\t\treturn cb(null);\n\t\t\t\t}\n\n\t\t\t\titem[property] = null;\n\n\t\t\t\treturn item.save(cb);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(Instance, \"set\" + method, {\n\t\tvalue: function (data, cb) {\n\t\t\tvar conditions = {};\n\t\t\tconditions[Model.id] = Instance[Model.id];\n\n\t\t\tModel.find(conditions, { identityCache: false }).first(function (err, item) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb(err);\n\t\t\t\t}\n\t\t\t\tif (!item) {\n\t\t\t\t\treturn cb(null);\n\t\t\t\t}\n\n\t\t\t\titem[property] = data;\n\n\t\t\t\treturn item.save(cb);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false\n\t});\n}\n\nfunction ucfirst(text) {\n\treturn text[0].toUpperCase() + text.substr(1).toLowerCase();\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Associations/Many.js":"var _                   = require(\"lodash\");\nvar InstanceConstructor = require(\"../Instance\").Instance;\nvar Hook                = require(\"../Hook\");\nvar Settings            = require(\"../Settings\");\nvar Property            = require(\"../Property\");\nvar ORMError            = require(\"../Error\");\nvar util                = require(\"../Utilities\");\n\nexports.prepare = function (db, Model, associations) {\n\tModel.hasMany = function () {\n\t\tvar name, makeKey, mergeId, mergeAssocId;\n\t\tvar OtherModel = Model;\n\t\tvar props = null;\n\t\tvar opts = {};\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\tcase \"string\":\n\t\t\t\t\tname = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tOtherModel = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"object\":\n\t\t\t\t\tif (props === null) {\n\t\t\t\t\t\tprops = arguments[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\topts = arguments[i];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (props === null) {\n\t\t\tprops = {};\n\t\t} else {\n\t\t\tfor (var k in props) {\n\t\t\t\tprops[k] = Property.normalize({\n\t\t\t\t\tprop: props[k], name: k, customTypes: db.customTypes, settings: Model.settings\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tmakeKey = opts.key || Settings.defaults().hasMany.key;\n\n\t\tmergeId = util.convertPropToJoinKeyProp(\n\t\t\tutil.wrapFieldObject({\n\t\t\t\tfield: opts.mergeId, model: Model, altName: Model.table\n\t\t\t}) ||\n\t\t\tutil.formatField(Model, Model.table, true, opts.reversed),\n\t\t\t{ makeKey: makeKey, required: true }\n\t\t);\n\n\t\tmergeAssocId = util.convertPropToJoinKeyProp(\n\t\t\tutil.wrapFieldObject({\n\t\t\t\tfield: opts.mergeAssocId, model: OtherModel, altName: name\n\t\t\t}) ||\n\t\t\tutil.formatField(OtherModel, name, true, opts.reversed),\n\t\t\t{ makeKey: makeKey, required: true }\n\t\t)\n\n\t\tvar assocName = opts.name || ucfirst(name);\n\t\tvar assocTemplateName = opts.accessor || assocName;\n\t\tvar association = {\n\t\t\tname           : name,\n\t\t\tmodel          : OtherModel || Model,\n\t\t\tprops          : props,\n\t\t\thooks          : opts.hooks || {},\n\t\t\tautoFetch      : opts.autoFetch || false,\n\t\t\tautoFetchLimit : opts.autoFetchLimit || 2,\n\t\t\t// I'm not sure the next key is used..\n\t\t\tfield          : util.wrapFieldObject({\n\t\t\t\t                 field: opts.field, model: OtherModel, altName: Model.table\n\t\t\t\t               }) ||\n\t\t\t                 util.formatField(Model, name, true, opts.reversed),\n\t\t\tmergeTable     : opts.mergeTable || (Model.table + \"_\" + name),\n\t\t\tmergeId        : mergeId,\n\t\t\tmergeAssocId   : mergeAssocId,\n\t\t\tgetAccessor    : opts.getAccessor || (\"get\" + assocTemplateName),\n\t\t\tsetAccessor    : opts.setAccessor || (\"set\" + assocTemplateName),\n\t\t\thasAccessor    : opts.hasAccessor || (\"has\" + assocTemplateName),\n\t\t\tdelAccessor    : opts.delAccessor || (\"remove\" + assocTemplateName),\n\t\t\taddAccessor    : opts.addAccessor || (\"add\" + assocTemplateName)\n\t\t};\n\t\tassociations.push(association);\n\n\t\tif (opts.reverse) {\n\t\t\tOtherModel.hasMany(opts.reverse, Model, association.props, {\n\t\t\t\treversed       : true,\n\t\t\t\tassociation    : opts.reverseAssociation,\n\t\t\t\tmergeTable     : association.mergeTable,\n\t\t\t\tmergeId        : association.mergeAssocId,\n\t\t\t\tmergeAssocId   : association.mergeId,\n\t\t\t\tfield          : association.field,\n\t\t\t\tautoFetch      : association.autoFetch,\n\t\t\t\tautoFetchLimit : association.autoFetchLimit\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t};\n};\n\nexports.extend = function (Model, Instance, Driver, associations, opts, createInstance) {\n\tfor (var i = 0; i < associations.length; i++) {\n\t\textendInstance(Model, Instance, Driver, associations[i], opts, createInstance);\n\t}\n};\n\nexports.autoFetch = function (Instance, associations, opts, cb) {\n\tif (associations.length === 0) {\n\t\treturn cb();\n\t}\n\n\tvar pending = associations.length;\n\tvar autoFetchDone = function autoFetchDone() {\n\t\tpending -= 1;\n\n\t\tif (pending === 0) {\n\t\t\treturn cb();\n\t\t}\n\t};\n\n\tfor (var i = 0; i < associations.length; i++) {\n\t\tautoFetchInstance(Instance, associations[i], opts, autoFetchDone);\n\t}\n};\n\nfunction extendInstance(Model, Instance, Driver, association, opts, createInstance) {\n\tif (Model.settings.get(\"instance.cascadeRemove\")) {\n\t\tInstance.on(\"beforeRemove\", function () {\n\t\t\tInstance[association.delAccessor]();\n\t\t});\n\t}\n\n\tfunction adjustForMapsTo(options) {\n\t\t// Loop through the (cloned) association model id fields ... some of them may've been mapped to different\n\t\t// names in the actual database - if so update to the mapped database column name\n\t\tfor(var i=0; i<options.__merge.to.field.length; i++) {\n\t\t\tvar idProp = association.model.properties[options.__merge.to.field[i]];\n\t\t\tif(idProp && idProp.mapsTo) {\n\t\t\t\toptions.__merge.to.field[i] = idProp.mapsTo;\n\t\t\t}\n\t\t}\n\t}\n\n\tObject.defineProperty(Instance, association.hasAccessor, {\n\t\tvalue: function () {\n\t\t\tvar Instances = Array.prototype.slice.apply(arguments);\n\t\t\tvar cb = Instances.pop();\n\t\t\tvar conditions = {}, options = {};\n\n\t\t\tif (Instances.length) {\n\t\t\t\tif (Array.isArray(Instances[0])) {\n\t\t\t\t\tInstances = Instances[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Driver.hasMany) {\n\t\t\t\treturn Driver.hasMany(Model, association).has(Instance, Instances, conditions, cb);\n\t\t\t}\n\n\t\t\toptions.autoFetchLimit = 0;\n\t\t\toptions.__merge = {\n\t\t\t\tfrom:   { table: association.mergeTable, field: Object.keys(association.mergeAssocId) },\n\t\t\t\tto: { table: association.model.table, field: association.model.id.slice(0) },   // clone model id\n\t\t\t\twhere:  [ association.mergeTable, {} ]\n\t\t\t};\n\n\t\t\tadjustForMapsTo(options);\n\n\t\t\toptions.extra = association.props;\n\t\t\toptions.extra_info = {\n\t\t\t\ttable: association.mergeTable,\n\t\t\t\tid: util.values(Instance, Model.id),\n\t\t\t\tid_prop: Object.keys(association.mergeId),\n\t\t\t\tassoc_prop: Object.keys(association.mergeAssocId)\n\t\t\t};\n\n\t\t\tutil.populateConditions(Model, Object.keys(association.mergeId), Instance, options.__merge.where[1]);\n\n\t\t\tfor (var i = 0; i < Instances.length; i++) {\n\t\t\t\tutil.populateConditions(association.model, Object.keys(association.mergeAssocId), Instances[i], options.__merge.where[1], false);\n\t\t\t}\n\n\t\t\tassociation.model.find(conditions, options, function (err, foundItems) {\n\t\t\t\tif (err)                  return cb(err);\n\t\t\t\tif (_.isEmpty(Instances)) return cb(null, false);\n\n\t\t\t\tvar mapKeysToString = function (item) {\n\t\t\t\t\treturn _.map(association.model.keys, function (k) {\n\t\t\t\t\t\treturn item[k];\n\t\t\t\t\t}).join(',')\n\t\t\t\t}\n\n\t\t\t\tvar foundItemsIDs = _(foundItems).map(mapKeysToString).uniq().value();\n\t\t\t\tvar InstancesIDs  = _(Instances ).map(mapKeysToString).uniq().value();\n\n\t\t\t\tvar sameLength   = foundItemsIDs.length == InstancesIDs.length;\n\t\t\t\tvar sameContents = sameLength && _.isEmpty(_.difference(foundItemsIDs, InstancesIDs));\n\n\t\t\t\treturn cb(null, sameContents);\n\t\t\t});\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(Instance, association.getAccessor, {\n\t\tvalue: function () {\n\t\t\tvar options    = {};\n\t\t\tvar conditions = null;\n\t\t\tvar order      = null;\n\t\t\tvar cb         = null;\n\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\tcb = arguments[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (Array.isArray(arguments[i])) {\n\t\t\t\t\t\t\torder = arguments[i];\n\t\t\t\t\t\t\torder[0] = [ association.model.table, order[0] ];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (conditions === null) {\n\t\t\t\t\t\t\t\tconditions = arguments[i];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\toptions = arguments[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\tif (arguments[i][0] == \"-\") {\n\t\t\t\t\t\t\torder = [ [ association.model.table, arguments[i].substr(1) ], \"Z\" ];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\torder = [ [ association.model.table, arguments[i] ] ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\toptions.limit = arguments[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (order !== null) {\n\t\t\t\toptions.order = order;\n\t\t\t}\n\n\t\t\tif (conditions === null) {\n\t\t\t\tconditions = {};\n\t\t\t}\n\n\t\t\tif (Driver.hasMany) {\n\t\t\t\treturn Driver.hasMany(Model, association).get(Instance, conditions, options, createInstance, cb);\n\t\t\t}\n\n\t\t\toptions.__merge = {\n\t\t\t\tfrom  : { table: association.mergeTable, field: Object.keys(association.mergeAssocId) },\n\t\t\t\tto    : { table: association.model.table, field: association.model.id.slice(0) }, // clone model id\n\t\t\t\twhere : [ association.mergeTable, {} ]\n\t\t\t};\n\n\t\t\tadjustForMapsTo(options);\n\n\t\t  options.extra = association.props;\n\t\t  options.extra_info = {\n\t\t\t   table: association.mergeTable,\n\t\t\t\tid: util.values(Instance, Model.id),\n\t\t\t\tid_prop: Object.keys(association.mergeId),\n\t\t\t\tassoc_prop: Object.keys(association.mergeAssocId)\n\t\t\t};\n\n\t\t\tutil.populateConditions(Model, Object.keys(association.mergeId), Instance, options.__merge.where[1]);\n\n\t\t\tif (cb === null) {\n\t\t\t\treturn association.model.find(conditions, options);\n\t\t\t}\n\n\t\t\tassociation.model.find(conditions, options, cb);\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(Instance, association.setAccessor, {\n\t\tvalue: function () {\n\t\t\tvar items = _.flatten(arguments);\n\t\t\tvar cb    = _.last(items) instanceof Function ? items.pop() : noOperation;\n\n\t\t\tInstance[association.delAccessor](function (err) {\n\t\t\t\tif (err) return cb(err);\n\n\t\t\t\tif (items.length) {\n\t\t\t\t\tInstance[association.addAccessor](items, cb);\n\t\t\t\t} else {\n\t\t\t\t\tcb(null);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(Instance, association.delAccessor, {\n\t\tvalue: function () {\n\t\t\tvar Associations = [];\n\t\t\tvar cb = noOperation;\n\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\tcb = arguments[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (Array.isArray(arguments[i])) {\n\t\t\t\t\t\t\tAssociations = Associations.concat(arguments[i]);\n\t\t\t\t\t\t} else if (arguments[i].isInstance) {\n\t\t\t\t\t\t\tAssociations.push(arguments[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar conditions = {};\n\t\t\tvar run = function () {\n\t\t\t\tif (Driver.hasMany) {\n\t\t\t\t\treturn Driver.hasMany(Model, association).del(Instance, Associations, cb);\n\t\t\t\t}\n\n\t\t\t\tif (Associations.length === 0) {\n\t\t\t\t\treturn Driver.remove(association.mergeTable, conditions, cb);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < Associations.length; i++) {\n\t\t\t\t\tutil.populateConditions(association.model, Object.keys(association.mergeAssocId), Associations[i], conditions, false);\n\t\t\t\t}\n\n\t\t\t\tDriver.remove(association.mergeTable, conditions, cb);\n\t\t\t};\n\n\t\t\tutil.populateConditions(Model, Object.keys(association.mergeId), Instance, conditions);\n\n\t\t\tif (this.saved()) {\n\t\t\t\trun();\n\t\t\t} else {\n\t\t\t\tthis.save(function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn run();\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(Instance, association.addAccessor, {\n\t\tvalue: function () {\n\t\t\tvar Associations = [];\n\t\t\tvar opts = {};\n\t\t\tvar cb = noOperation;\n\n\t\t\tvar run = function () {\n\t\t\t\tvar savedAssociations = [];\n\t\t\t\tvar saveNextAssociation = function () {\n\t\t\t\t\tif (Associations.length === 0) {\n\t\t\t\t\t\treturn cb(null, savedAssociations);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar Association = Associations.pop();\n\t\t\t\t\tvar saveAssociation = function (err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAssociation.save(function (err) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar data = {};\n\n\t\t\t\t\t\t\tfor (var k in opts) {\n\t\t\t\t\t\t\t\tif (k in association.props && Driver.propertyToValue) {\n\t\t\t\t\t\t\t\t\tdata[k] = Driver.propertyToValue(opts[k], association.props[k]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdata[k] = opts[k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (Driver.hasMany) {\n\t\t\t\t\t\t\t\treturn Driver.hasMany(Model, association).add(Instance, Association, data, function (err) {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tsavedAssociations.push(Association);\n\n\t\t\t\t\t\t\t\t\treturn saveNextAssociation();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tutil.populateConditions(Model, Object.keys(association.mergeId), Instance, data);\n\t\t\t\t\t\t\tutil.populateConditions(association.model, Object.keys(association.mergeAssocId), Association, data);\n\n\t\t\t\t\t\t\tDriver.insert(association.mergeTable, data, null, function (err) {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsavedAssociations.push(Association);\n\n\t\t\t\t\t\t\t\treturn saveNextAssociation();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tif (Object.keys(association.props).length) {\n\t\t\t\t\t\tHook.wait(Association, association.hooks.beforeSave, saveAssociation, opts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tHook.wait(Association, association.hooks.beforeSave, saveAssociation);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\treturn saveNextAssociation();\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\tcb = arguments[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (Array.isArray(arguments[i])) {\n\t\t\t\t\t\t\tAssociations = Associations.concat(arguments[i]);\n\t\t\t\t\t\t} else if (arguments[i].isInstance) {\n\t\t\t\t\t\t\tAssociations.push(arguments[i]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topts = arguments[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Associations.length === 0) {\n\t\t\t    throw new ORMError(\"No associations defined\", 'PARAM_MISMATCH', { model: Model.name });\n\t\t\t}\n\n\t\t\tif (this.saved()) {\n\t\t\t\trun();\n\t\t\t} else {\n\t\t\t\tthis.save(function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn run();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\n\tObject.defineProperty(Instance, association.name, {\n\t\tget: function () {\n\t\t\treturn Instance.__opts.associations[association.name].value;\n\t\t},\n\t\tset: function (val) {\n\t\t\tInstance.__opts.associations[association.name].changed = true;\n\t\t\tInstance.__opts.associations[association.name].value   = val;\n\t\t},\n\t\tenumerable: true\n\t});\n}\n\nfunction autoFetchInstance(Instance, association, opts, cb) {\n\tif (!Instance.saved()) {\n\t\treturn cb();\n\t}\n\n\tif (!opts.hasOwnProperty(\"autoFetchLimit\") || typeof opts.autoFetchLimit == \"undefined\") {\n\t\topts.autoFetchLimit = association.autoFetchLimit;\n\t}\n\n\tif (opts.autoFetchLimit === 0 || (!opts.autoFetch && !association.autoFetch)) {\n\t\treturn cb();\n\t}\n\n\tInstance[association.getAccessor]({}, { autoFetchLimit: opts.autoFetchLimit - 1 }, function (err, Assoc) {\n\t\tif (!err) {\n\t\t\t// Set this way to prevent setting 'changed' status\n\t\t\tInstance.__opts.associations[association.name].value = Assoc;\n\t\t}\n\n\t\treturn cb();\n\t});\n}\n\nfunction ucfirst(text) {\n\treturn text[0].toUpperCase() + text.substr(1).replace(/_([a-z])/, function (m, l) {\n\t\treturn l.toUpperCase();\n\t});\n}\n\nfunction noOperation() {\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Settings.js":"var _ = require('lodash');\nvar default_settings = {\n\tproperties : {\n\t\tprimary_key               : \"id\",\n\t\tassociation_key           : \"{name}_{field}\",\n\t\trequired                  : false\n\t},\n\tinstance   : {\n\t\tidentityCache             : false,\n\t\tidentityCacheSaveCheck    : true,\n\t\tautoSave                  : false,\n\t\tautoFetch                 : false,\n\t\tautoFetchLimit            : 1,\n\t\tcascadeRemove             : true,\n\t\treturnAllErrors           : false,\n\t\tsaveAssociationsByDefault : true\n\t},\n\thasMany    : {\n\t\t// Makes the foreign key fields a composite key\n\t\tkey                       : false\n\t},\n\tconnection : {\n\t\treconnect                 : true,\n\t\tpool                      : false,\n\t\tdebug                     : false\n\t}\n};\n\nexports.Container = Settings;\nexports.defaults = function () {\n\treturn default_settings;\n};\n\nfunction Settings(settings) {\n\tthis.settings = settings;\n\n\treturn {\n\t\tset: function (key, value) {\n\t\t\tset(key, value, settings);\n\n\t\t\treturn this;\n\t\t},\n\t\tget: function (key, def) {\n\t\t\tvar v = get(key, def, settings)\n\n\t\t\tif (v instanceof Function) {\n\t\t\t\treturn v;\n\t\t\t} else {\n\t\t\t\treturn _.cloneDeep(v);\n\t\t\t}\n\t\t},\n\t\tunset: function () {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tif (typeof arguments[i] === \"string\") {\n\t\t\t\t\tunset(arguments[i], settings);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\nfunction set(key, value, obj) {\n\tvar p = key.indexOf(\".\");\n\n\tif (p === -1) {\n\t\treturn obj[key] = value;\n\t}\n\n\tif (!obj.hasOwnProperty(key.substr(0, p))) {\n\t\tobj[key.substr(0, p)] = {};\n\t}\n\n\treturn set(key.substr(p + 1), value, obj[key.substr(0, p)]);\n}\n\nfunction get(key, def, obj) {\n\tvar p = key.indexOf(\".\");\n\n\tif (p === -1) {\n\t\tif (key === '*') {\n\t\t\treturn obj;\n\t\t}\n\t\treturn obj.hasOwnProperty(key) ? obj[key] : def;\n\t}\n\n\tif (!obj.hasOwnProperty(key.substr(0, p))) {\n\t\treturn def;\n\t}\n\n\treturn get(key.substr(p + 1), def, obj[key.substr(0, p)]);\n}\n\nfunction unset(key, obj) {\n\tvar p = key.indexOf(\".\");\n\n\tif (p === -1) {\n\t\tif (key === '*') {\n\t\t\treturn 'reset';\n\t\t} else {\n\t\t\tdelete obj[key];\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!obj.hasOwnProperty(key.substr(0, p))) {\n\t\treturn;\n\t}\n\n\tif (unset(key.substr(p + 1), obj[key.substr(0, p)]) === 'reset') {\n\t\tobj[key.substr(0, p)] = {};\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Associations/One.js":"var _          = require(\"lodash\");\nvar util       = require(\"../Utilities\");\nvar ORMError   = require(\"../Error\");\nvar Accessors  = { \"get\": \"get\", \"set\": \"set\", \"has\": \"has\", \"del\": \"remove\" };\n\nexports.prepare = function (Model, associations) {\n\tModel.hasOne = function () {\n\t\tvar assocName;\n\t\tvar assocTemplateName;\n\t\tvar association = {\n\t\t\tname           : Model.table,\n\t\t\tmodel          : Model,\n\t\t\treversed       : false,\n\t\t\textension      : false,\n\t\t\tautoFetch      : false,\n\t\t\tautoFetchLimit : 2,\n\t\t\trequired       : false\n\t\t};\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\tcase \"string\":\n\t\t\t\t\tassociation.name = arguments[i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tif (arguments[i].table) {\n\t\t\t\t\t\tassociation.model = arguments[i];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"object\":\n\t\t\t\t\tassociation = _.extend(association, arguments[i]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassocName = ucfirst(association.name);\n\t\tassocTemplateName = association.accessor || assocName;\n\n\t\tif (!association.hasOwnProperty(\"field\")) {\n\t\t\tassociation.field = util.formatField(association.model, association.name, association.required, association.reversed);\n\t\t} else if(!association.extension) {\n\t\t\tassociation.field = util.wrapFieldObject({\n\t\t\t\tfield: association.field, model: Model, altName: Model.table,\n\t\t\t\tmapsTo: association.mapsTo\n\t\t\t});\n\t\t}\n\n\t\tutil.convertPropToJoinKeyProp(association.field, {\n\t\t\tmakeKey: false, required: association.required\n\t\t});\n\n\t\tfor (var k in Accessors) {\n\t\t\tif (!association.hasOwnProperty(k + \"Accessor\")) {\n\t\t\t\tassociation[k + \"Accessor\"] = Accessors[k] + assocTemplateName;\n\t\t\t}\n\t\t}\n\n\t\tassociations.push(association);\n\t\tfor (k in association.field) {\n\t\t\tif (!association.field.hasOwnProperty(k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!association.reversed) {\n\t\t\t\tModel.addProperty(\n\t\t\t\t\t_.extend({}, association.field[k], { klass: 'hasOne' }),\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (association.reverse) {\n\t\t\tassociation.model.hasOne(association.reverse, Model, {\n\t\t\t\treversed       : true,\n\t\t\t\taccessor       : association.reverseAccessor,\n\t\t\t\treverseAccessor: undefined,\n\t\t\t\tfield          : association.field,\n\t\t\t\tautoFetch      : association.autoFetch,\n\t\t\t\tautoFetchLimit : association.autoFetchLimit\n\t\t\t});\n\t\t}\n\n\t\tModel[\"findBy\" + assocTemplateName] = function () {\n\t\t\tvar cb = null, conditions = null, options = {};\n\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\tcb = arguments[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (conditions === null) {\n\t\t\t\t\t\t\tconditions = arguments[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toptions = arguments[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (conditions === null) {\n\t\t\t\tthrow new ORMError(\".findBy(\" + assocName + \") is missing a conditions object\", 'PARAM_MISMATCH');\n\t\t\t}\n\n\t\t\toptions.__merge = {\n\t\t\t\tfrom  : { table: association.model.table, field: (association.reversed ? Object.keys(association.field) : association.model.id) },\n\t\t\t\tto    : { table: Model.table, field: (association.reversed ? association.model.id : Object.keys(association.field) ) },\n\t\t\t\twhere : [ association.model.table, conditions ],\n\t\t\t\ttable : Model.table\n\t\t\t};\n\t\t\toptions.extra = [];\n\n\t\t\tif (typeof cb === \"function\") {\n\t\t\t\treturn Model.find({}, options, cb);\n\t\t\t}\n\t\t\treturn Model.find({}, options);\n\t\t};\n\n\t\treturn this;\n\t};\n};\n\nexports.extend = function (Model, Instance, Driver, associations) {\n\tfor (var i = 0; i < associations.length; i++) {\n\t\textendInstance(Model, Instance, Driver, associations[i]);\n\t}\n};\n\nexports.autoFetch = function (Instance, associations, opts, cb) {\n\tif (associations.length === 0) {\n\t\treturn cb();\n\t}\n\n\tvar pending = associations.length;\n\tvar autoFetchDone = function autoFetchDone() {\n\t\tpending -= 1;\n\n\t\tif (pending === 0) {\n\t\t\treturn cb();\n\t\t}\n\t};\n\n\tfor (var i = 0; i < associations.length; i++) {\n\t\tautoFetchInstance(Instance, associations[i], opts, autoFetchDone);\n\t}\n};\n\nfunction extendInstance(Model, Instance, Driver, association) {\n\tObject.defineProperty(Instance, association.hasAccessor, {\n\t\tvalue: function (opts, cb) {\n\t\t\tif (typeof opts === \"function\") {\n\t\t\t\tcb = opts;\n\t\t\t\topts = {};\n\t\t\t}\n\n\t\t\tif (util.hasValues(Instance, Object.keys(association.field))) {\n\t\t\t\tassociation.model.get(util.values(Instance, Object.keys(association.field)), opts, function (err, instance) {\n\t\t\t\t\treturn cb(err, instance ? true : false);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcb(null, false);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(Instance, association.getAccessor, {\n\t\tvalue: function (opts, cb) {\n\t\t\tif (typeof opts === \"function\") {\n\t\t\t\tcb = opts;\n\t\t\t\topts = {};\n\t\t\t}\n\n\t\t\tvar saveAndReturn = function (err, Assoc) {\n\t\t\t\tif (!err) {\n\t\t\t\t\tInstance[association.name] = Assoc;\n\t\t\t\t}\n\n\t\t\t\treturn cb(err, Assoc);\n\t\t\t};\n\n\t\t\tif (association.reversed) {\n\t\t\t\tif (util.hasValues(Instance, Model.id)) {\n\t\t\t\t\tif (typeof cb !== \"function\") {\n\t\t\t\t\t\treturn association.model.find(util.getConditions(Model, Object.keys(association.field), Instance), opts);\n\t\t\t\t\t}\n\t\t\t\t\tassociation.model.find(util.getConditions(Model, Object.keys(association.field), Instance), opts, saveAndReturn);\n\t\t\t\t} else {\n\t\t\t\t\tcb(null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (Instance.isShell()) {\n\t\t\t\t\tModel.get(util.values(Instance, Model.id), function (err, instance) {\n\t\t\t\t\t\tif (err || !util.hasValues(instance, Object.keys(association.field))) {\n\t\t\t\t\t\t\treturn cb(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassociation.model.get(util.values(instance, Object.keys(association.field)), opts, saveAndReturn);\n\t\t\t\t\t});\n\t\t\t\t} else if (util.hasValues(Instance, Object.keys(association.field))) {\n\t\t\t\t\tassociation.model.get(util.values(Instance, Object.keys(association.field)), opts, saveAndReturn);\n\t\t\t\t} else {\n\t\t\t\t\tcb(null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tObject.defineProperty(Instance, association.setAccessor, {\n\t\tvalue: function (OtherInstance, cb) {\n\t\t\tif (association.reversed) {\n\t\t\t\tInstance.save(function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Array.isArray(OtherInstance)) {\n\t\t\t\t\t\tutil.populateConditions(Model, Object.keys(association.field), Instance, OtherInstance, true);\n\n\t\t\t\t\t\treturn OtherInstance.save({}, { saveAssociations: false }, cb);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar associations = _.clone(OtherInstance);\n\n\t\t\t\t\tvar saveNext = function () {\n\t\t\t\t\t\tif (!associations.length) {\n\t\t\t\t\t\t\treturn cb();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar other = associations.pop();\n\n\t\t\t\t\t\tutil.populateConditions(Model, Object.keys(association.field), Instance, other, true);\n\n\t\t\t\t\t\tother.save({}, { saveAssociations: false }, function (err) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsaveNext();\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\treturn saveNext();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tOtherInstance.save({}, { saveAssociations: false }, function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tInstance[association.name] = OtherInstance;\n\n\t\t\t\t\tutil.populateConditions(association.model, Object.keys(association.field), OtherInstance, Instance);\n\n\t\t\t\t\treturn Instance.save({}, { saveAssociations: false }, cb);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\tenumerable: false,\n\t\twritable: true\n\t});\n\tif (!association.reversed) {\n\t\tObject.defineProperty(Instance, association.delAccessor, {\n\t\t\tvalue: function (cb) {\n\t\t\t\tfor (var k in association.field) {\n\t\t\t\t\tif (association.field.hasOwnProperty(k)) {\n\t\t\t\t\t\tInstance[k] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tInstance.save({}, { saveAssociations: false }, function (err) {\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tdelete Instance[association.name];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn cb();\n\t\t\t\t});\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tenumerable: false,\n\t\t\twritable: true\n\t\t});\n\t}\n}\n\nfunction autoFetchInstance(Instance, association, opts, cb) {\n\tif (!Instance.saved()) {\n\t\treturn cb();\n\t}\n\n\tif (!opts.hasOwnProperty(\"autoFetchLimit\") || typeof opts.autoFetchLimit === \"undefined\") {\n\t\topts.autoFetchLimit = association.autoFetchLimit;\n\t}\n\n\tif (opts.autoFetchLimit === 0 || (!opts.autoFetch && !association.autoFetch)) {\n\t\treturn cb();\n\t}\n\n\t// When we have a new non persisted instance for which the association field (eg owner_id)\n\t// is set, we don't want to auto fetch anything, since `new Model(owner_id: 12)` takes no\n\t// callback, and hence this lookup would complete at an arbitrary point in the future.\n\t// The associated entity should probably be fetched when the instance is persisted.\n\tif (Instance.isPersisted()) {\n\t\tInstance[association.getAccessor]({ autoFetchLimit: opts.autoFetchLimit - 1 }, cb);\n\t} else {\n\t\treturn cb();\n\t}\n}\n\nfunction ucfirst(text) {\n\treturn text[0].toUpperCase() + text.substr(1);\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Associations/Extend.js":"var _          = require('lodash');\nvar ORMError   = require(\"../Error\");\nvar Settings   = require(\"../Settings\");\nvar Singleton  = require(\"../Singleton\");\nvar util       = require(\"../Utilities\");\n\nexports.prepare = function (db, Model, associations) {\n\tModel.extendsTo = function (name, properties, opts) {\n\t\topts = opts || {};\n\n\t\tvar assocName = opts.name || ucfirst(name);\n\t\tvar association = {\n\t\t\tname           : name,\n\t\t\ttable          : opts.table || (Model.table + '_' + name),\n\t\t\treversed       : opts.reversed,\n\t\t\tautoFetch      : opts.autoFetch || false,\n\t\t\tautoFetchLimit : opts.autoFetchLimit || 2,\n\t\t\tfield          : util.wrapFieldObject({\n\t\t\t\t\t\t\t\t\t\t\t\t field: opts.field, model: Model, altName: Model.table\n\t\t\t\t\t\t\t\t\t\t\t }) || util.formatField(Model, Model.table, false, false),\n\t\t\tgetAccessor    : opts.getAccessor || (\"get\" + assocName),\n\t\t\tsetAccessor    : opts.setAccessor || (\"set\" + assocName),\n\t\t\thasAccessor    : opts.hasAccessor || (\"has\" + assocName),\n\t\t\tdelAccessor    : opts.delAccessor || (\"remove\" + assocName)\n\t\t};\n\n\t\tvar newproperties = _.cloneDeep(properties);\n\t\tfor (var k in association.field) {\n\t\t    newproperties[k] = association.field[k];\n\t\t}\n\n\t\tvar modelOpts = _.extend(\n\t\t\t_.pick(opts, 'identityCache', 'autoSave', 'cascadeRemove', 'hooks', 'methods', 'validations'),\n\t\t\t{\n\t\t\t\tid        : Object.keys(association.field),\n\t\t\t\textension : true,\n\t\t\t}\n\t\t);\n\n\t\tassociation.model = db.define(association.table, newproperties, modelOpts);\n\t\tassociation.model.hasOne(Model.table, Model, { extension: true, field: association.field });\n\n\t\tassociations.push(association);\n\n\t\tModel[\"findBy\" + assocName] = function () {\n\t\t\tvar cb = null, conditions = null, options = {};\n\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tswitch (typeof arguments[i]) {\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\tcb = arguments[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (conditions === null) {\n\t\t\t\t\t\t\tconditions = arguments[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toptions = arguments[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (conditions === null) {\n\t\t\t\tthrow new ORMError(\".findBy(\" + assocName + \") is missing a conditions object\", 'PARAM_MISMATCH');\n\t\t\t}\n\n\t\t\toptions.__merge = {\n\t\t\t\tfrom  : { table: association.model.table, field: Object.keys(association.field) },\n\t\t\t\tto    : { table: Model.table, field: Model.id },\n\t\t\t\twhere : [ association.model.table, conditions ],\n\t\t\t\ttable : Model.table\n\t\t\t};\n\t\t\toptions.extra = [];\n\n\t\t\tif (typeof cb == \"function\") {\n\t\t\t\treturn Model.find({}, options, cb);\n\t\t\t}\n\t\t\treturn Model.find({}, options);\n\t\t};\n\n\t\treturn association.model;\n\t};\n};\n\nexports.extend = function (Model, Instance, Driver, associations, opts) {\n\tfor (var i = 0; i < associations.length; i++) {\n\t\textendInstance(Model, Instance, Driver, associations[i], opts);\n\t}\n};\n\nexports.autoFetch = function (Instance, associations, opts, cb) {\n\tif (associations.length === 0) {\n\t\treturn cb();\n\t}\n\n\tvar pending = associations.length;\n\tvar autoFetchDone = function autoFetchDone() {\n\t\tpending -= 1;\n\n\t\tif (pending === 0) {\n\t\t\treturn cb();\n\t\t}\n\t};\n\n\tfor (var i = 0; i < associations.length; i++) {\n\t\tautoFetchInstance(Instance, associations[i], opts, autoFetchDone);\n\t}\n};\n\nfunction extendInstance(Model, Instance, Driver, association, opts) {\n\tObject.defineProperty(Instance, association.hasAccessor, {\n\t\tvalue : function (cb) {\n\t\t\tif (!Instance[Model.id]) {\n\t\t\t    cb(new ORMError(\"Instance not saved, cannot get extension\", 'NOT_DEFINED', { model: Model.table }));\n\t\t\t} else {\n\t\t\t\tassociation.model.get(util.values(Instance, Model.id), function (err, extension) {\n\t\t\t\t\treturn cb(err, !err && extension ? true : false);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tenumerable : false\n\t});\n\tObject.defineProperty(Instance, association.getAccessor, {\n\t\tvalue: function (opts, cb) {\n\t\t\tif (typeof opts == \"function\") {\n\t\t\t\tcb = opts;\n\t\t\t\topts = {};\n\t\t\t}\n\n\t\t\tif (!Instance[Model.id]) {\n\t\t\t    cb(new ORMError(\"Instance not saved, cannot get extension\", 'NOT_DEFINED', { model: Model.table }));\n\t\t\t} else {\n\t\t\t\tassociation.model.get(util.values(Instance, Model.id), opts, cb);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tenumerable : false\n\t});\n\tObject.defineProperty(Instance, association.setAccessor, {\n\t\tvalue : function (Extension, cb) {\n\t\t\tInstance.save(function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb(err);\n\t\t\t\t}\n\n\t\t\t\tInstance[association.delAccessor](function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar fields = Object.keys(association.field);\n\n\t\t\t\t\tif (!Extension.isInstance) {\n\t\t\t\t\t\tExtension = new association.model(Extension);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < Model.id.length; i++) {\n\t\t\t\t\t\tExtension[fields[i]] = Instance[Model.id[i]];\n\t\t\t\t\t}\n\n\t\t\t\t\tExtension.save(cb);\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn this;\n\t\t},\n\t\tenumerable : false\n\t});\n\tObject.defineProperty(Instance, association.delAccessor, {\n\t\tvalue : function (cb) {\n\t\t\tif (!Instance[Model.id]) {\n\t\t\t    cb(new ORMError(\"Instance not saved, cannot get extension\", 'NOT_DEFINED', { model: Model.table }));\n\t\t\t} else {\n\t\t\t\tvar conditions = {};\n\t\t\t\tvar fields = Object.keys(association.field);\n\n\t\t\t\tfor (var i = 0; i < Model.id.length; i++) {\n\t\t\t\t    conditions[fields[i]] = Instance[Model.id[i]];\n\t\t\t\t}\n\n\t\t\t\tassociation.model.find(conditions, function (err, extensions) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar pending = extensions.length;\n\n\t\t\t\t\tfor (var i = 0; i < extensions.length; i++) {\n\t\t\t\t\t\tSingleton.clear(extensions[i].__singleton_uid());\n\t\t\t\t\t\textensions[i].remove(function () {\n\t\t\t\t\t\t\tif (--pending === 0) {\n\t\t\t\t\t\t\t\treturn cb();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pending === 0) {\n\t\t\t\t\t\treturn cb();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tenumerable : false\n\t});\n}\n\nfunction autoFetchInstance(Instance, association, opts, cb) {\n\tif (!Instance.saved()) {\n\t\treturn cb();\n\t}\n\n\tif (!opts.hasOwnProperty(\"autoFetchLimit\") || typeof opts.autoFetchLimit == \"undefined\") {\n\t\topts.autoFetchLimit = association.autoFetchLimit;\n\t}\n\n\tif (opts.autoFetchLimit === 0 || (!opts.autoFetch && !association.autoFetch)) {\n\t\treturn cb();\n\t}\n\n\tif (Instance.isPersisted()) {\n\t\tInstance[association.getAccessor]({ autoFetchLimit: opts.autoFetchLimit - 1 }, function (err, Assoc) {\n\t\t\tif (!err) {\n\t\t\t\tInstance[association.name] = Assoc;\n\t\t\t}\n\n\t\t\treturn cb();\n\t\t});\n\t} else {\n\t\treturn cb();\n\t}\n}\n\nfunction ucfirst(text) {\n\treturn text[0].toUpperCase() + text.substr(1);\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Singleton.js":"var map = {};\n\nexports.clear = function (key) {\n\tif (typeof key === \"string\") {\n\t\tdelete map[key];\n\t} else {\n\t\tmap = {};\n\t}\n\treturn this;\n};\n\nexports.get = function (key, opts, createCb, returnCb) {\n\tif (opts && opts.identityCache === false) {\n\t\treturn createCb(returnCb);\n\t}\n\tif (map.hasOwnProperty(key)) {\n\t\tif (opts && opts.saveCheck && typeof map[key].o.saved === \"function\" && !map[key].o.saved()) {\n\t\t\t// if not saved, don't return it, fetch original from db\n\t\t\treturn createCb(returnCb);\n\t\t} else if (map[key].t !== null && map[key].t <= Date.now()) {\n\t\t\tdelete map[key];\n\t\t} else  {\n\t\t\treturn returnCb(null, map[key].o);\n\t\t}\n\t}\n\n\tcreateCb(function (err, value) {\n\t\tif (err) return returnCb(err);\n\n\t\tmap[key] = { // object , timeout\n\t\t\to : value,\n\t\t\tt : (opts && typeof opts.identityCache === \"number\" ? Date.now() + (opts.identityCache * 1000) : null)\n\t\t};\n\t\treturn returnCb(null, map[key].o);\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Validators.js":"var enforce = require(\"enforce\");\nvar util    = require(\"util\");\n\nvar validators = {\n\trequired       : enforce.required,\n\tnotEmptyString : enforce.notEmptyString,\n\n\trangeNumber    : enforce.ranges.number,\n\trangeLength    : enforce.ranges.length,\n\n\tinsideList     : enforce.lists.inside,\n\toutsideList    : enforce.lists.outside,\n\n\tpassword       : enforce.security.password,\n\n\tpatterns       : enforce.patterns\n};\n\n\n/**\n * Check if a value is the same as a value\n * of another property (useful for password\n * checking).\n **/\nvalidators.equalToProperty = function (name, msg) {\n\treturn function (v, next) {\n\t\tif (v === this[name]) {\n\t\t\treturn next();\n\t\t}\n\t\treturn next(msg || 'not-equal-to-property');\n\t};\n};\n\n/**\n * Check if a property is unique in the collection.\n * This can take a while because a query has to be made against the Model.\n *\n * Due to the async nature of node, and concurrent web server environments,\n * an index on the database column is the only way to gurantee uniqueness.\n *\n * For sensibility's sake, undefined and null values are ignored for uniqueness\n * checks.\n *\n * Options:\n *   ignoreCase: for postgres; mysql ignores case by default.\n *   scope: (Array) scope uniqueness to listed properties\n **/\nvalidators.unique = function () {\n\tvar arg, k;\n\tvar msg = null, opts = {};\n\n\tfor (k in arguments) {\n\t\targ = arguments[k];\n\t\tif (typeof arg === \"string\") {\n\t\t\tmsg = arg;\n\t\t} else if (typeof arg === \"object\") {\n\t\t\topts = arg;\n\t\t}\n\t}\n\n\treturn function (v, next, ctx) {\n\t\tvar s, scopeProp;\n\n\t\tif (typeof v === \"undefined\" || v === null) {\n\t\t\treturn next();\n\t\t}\n\n\t\t//Cannot process on database engines which don't support SQL syntax\n\t\tif (!ctx.driver.isSql) {\n\t\t\treturn next('not-supported');\n\t\t}\n\n\t\tvar chain = ctx.model.find();\n\n\t\tvar chainQuery = function (prop, value) {\n\t\t\tvar query = null;\n\n\t\t\tif (opts.ignoreCase === true && ctx.model.properties[prop] && ctx.model.properties[prop].type === 'text') {\n\t\t\t\tquery = util.format('LOWER(%s.%s) LIKE LOWER(?)',\n\t\t\t\t\tctx.driver.query.escapeId(ctx.model.table), ctx.driver.query.escapeId(prop)\n\t\t\t\t);\n\t\t\t\tchain.where(query, [value]);\n\t\t\t} else {\n\t\t\t\tquery = {};\n\t\t\t\tquery[prop] = value;\n\t\t\t\tchain.where(query);\n\t\t\t}\n\t\t};\n\n\t\tvar handler = function (err, records) {\n\t\t\tif (err) {\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\tif (!records || records.length === 0) {\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\tif (records.length === 1 && records[0][ctx.model.id] === this[ctx.model.id]) {\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\treturn next(msg || 'not-unique');\n\t\t}.bind(this);\n\n\t\tchainQuery(ctx.property, v);\n\n\t\tif (opts.scope) {\n\t\t\tfor (s in opts.scope) {\n\t\t\t\tscopeProp = opts.scope[s];\n\n\t\t\t\t// In SQL unique index land, NULL values are not considered equal.\n\t\t\t\tif (typeof ctx.instance[scopeProp] == 'undefined' || ctx.instance[scopeProp] === null) {\n\t\t\t\t\treturn next();\n\t\t\t\t}\n\n\t\t\t\tchainQuery(scopeProp, ctx.instance[scopeProp]);\n\t\t\t}\n\t\t}\n\n\t\tchain.all(handler);\n\t};\n};\n\nmodule.exports = validators;\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Drivers/aliases.js":"module.exports = {\n\tpostgresql : \"postgres\",\n\tpg         : \"postgres\",\n\n\tmongo      : \"mongodb\"\n};\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Adapters.js":"var aliases = require('./Drivers/aliases');\n\nmodule.exports.add = addAdapter;\nmodule.exports.get = getAdapter;\n\n\nvar adapters = {};\n\nfunction addAdapter(name, constructor) {\n  adapters[name] = constructor;\n}\n\nfunction getAdapter(name) {\n  if (name in aliases) {\n    return getAdapter(aliases[name]);\n  } else if (!(name in adapters)) {\n    adapters[name] = require(\"./Drivers/DML/\" + name).Driver;\n  }\n\n  return adapters[name];\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/AggregateFunctions.js":"var ORMError   = require(\"./Error\");\nvar Utilities  = require(\"./Utilities\");\n\nmodule.exports = AggregateFunctions;\n\nfunction AggregateFunctions(opts) {\n\tif (typeof opts.driver.getQuery !== \"function\") {\n\t\tthrow new ORMError('NO_SUPPORT', \"This driver does not support aggregate functions\");\n\t}\n\tif (!Array.isArray(opts.driver.aggregate_functions)) {\n\t\tthrow new ORMError('NO_SUPPORT', \"This driver does not support aggregate functions\");\n\t}\n\n\tvar aggregates    = [ [] ];\n\tvar group_by      = null;\n\tvar used_distinct = false;\n\n\tvar appendFunction = function (fun) {\n\t\treturn function () {\n\t\t\tvar args = (arguments.length && Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.apply(arguments));\n\n\t\t\tif (args.length > 0) {\n\t\t\t\taggregates[aggregates.length - 1].push({ f: fun, a: args, alias: aggregateAlias(fun, args) });\n\t\t\t\taggregates.push([]);\n\t\t\t} else {\n\t\t\t\taggregates[aggregates.length - 1].push({ f: fun, alias: aggregateAlias(fun, args) });\n\t\t\t}\n\n\t\t\tif (fun === \"distinct\") {\n\t\t\t\tused_distinct = true;\n\t\t\t}\n\n\t\t\treturn proto;\n\t\t};\n\t};\n\tvar proto = {\n\t\tgroupBy: function () {\n\t\t\tgroup_by = Array.prototype.slice.apply(arguments);\n\t\t\treturn this;\n\t\t},\n\t\tlimit: function (offset, limit) {\n\t\t\tif (typeof limit === \"number\") {\n\t\t\t\topts.limit = [ offset, limit ];\n\t\t\t} else {\n\t\t\t\topts.limit = [ 0, offset ]; // offset = limit\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\torder: function () {\n\t\t\topts.order = Utilities.standardizeOrder(Array.prototype.slice.apply(arguments));\n\t\t\treturn this;\n\t\t},\n\t\tselect: function () {\n\t\t\tif (arguments.length === 0) {\n\t\t\t\tthrow new ORMError('PARAM_MISMATCH', \"When using append you must at least define one property\");\n\t\t\t}\n\t\t\tif (Array.isArray(arguments[0])) {\n\t\t\t\topts.propertyList = opts.propertyList.concat(arguments[0]);\n\t\t\t} else {\n\t\t\t\topts.propertyList = opts.propertyList.concat(Array.prototype.slice.apply(arguments));\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tas: function (alias) {\n\t\t\tif (aggregates.length === 0 || (aggregates.length === 1 && aggregates[0].length === 0)) {\n\t\t\t\tthrow new ORMError('PARAM_MISMATCH', \"No aggregate functions defined yet\");\n\t\t\t}\n\n\t\t\tvar len = aggregates.length;\n\n\t\t\taggregates[len - 1][aggregates[len - 1].length - 1].alias = alias;\n\n\t\t\treturn this;\n\t\t},\n\t\tcall: function (fun, args) {\n\t\t\tif (args && args.length > 0) {\n\t\t\t\taggregates[aggregates.length - 1].push({ f: fun, a: args, alias: aggregateAlias(fun, args) });\n\t\t\t\t// aggregates.push([]);\n\t\t\t} else {\n\t\t\t\taggregates[aggregates.length - 1].push({ f: fun, alias: aggregateAlias(fun, args) });\n\t\t\t}\n\n\t\t\tif (fun.toLowerCase() === \"distinct\") {\n\t\t\t\tused_distinct = true;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\tget: function (cb) {\n\t\t\tif (typeof cb !== \"function\") {\n\t\t\t\tthrow new ORMError('MISSING_CALLBACK', \"You must pass a callback to Model.aggregate().get()\");\n\t\t\t}\n\t\t\tif (aggregates[aggregates.length - 1].length === 0) {\n\t\t\t\taggregates.length -= 1;\n\t\t\t}\n\t\t\tif (aggregates.length === 0) {\n\t\t\t\tthrow new ORMError('PARAM_MISMATCH', \"Missing aggregate functions\");\n\t\t\t}\n\n\t\t\tvar query = opts.driver.getQuery().select().from(opts.table).select(opts.propertyList);\n\t\t\tvar i, j;\n\n\t\t\tfor (i = 0; i < aggregates.length; i++) {\n\t\t\t\tfor (j = 0; j < aggregates[i].length; j++) {\n\t\t\t\t\tquery.fun(aggregates[i][j].f, aggregates[i][j].a, aggregates[i][j].alias);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tquery.where(opts.conditions);\n\n\t\t\tif (group_by !== null) {\n\t\t\t\tquery.groupBy.apply(query, group_by);\n\t\t\t}\n\n\t\t\tif (opts.order) {\n\t\t\t\tfor (i = 0; i < opts.order.length; i++) {\n\t\t\t\t\tquery.order(opts.order[i][0], opts.order[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (opts.limit) {\n\t\t\t\tquery.offset(opts.limit[0]).limit(opts.limit[1]);\n\t\t\t}\n\n\t\t\tquery = query.build();\n\n\t\t\topts.driver.execQuery(query, function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb(err);\n\t\t\t\t}\n\n\t\t\t\tif (group_by !== null) {\n\t\t\t\t\treturn cb(null, data);\n\t\t\t\t}\n\n\t\t\t\tvar items = [], i;\n\n\t\t\t\tif (used_distinct && aggregates.length === 1) {\n\t\t\t\t\tfor (i = 0; i < data.length; i++) {\n\t\t\t\t\t\titems.push(data[i][Object.keys(data[i]).pop()]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn cb(null, items);\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < aggregates.length; i++) {\n\t\t\t\t\tfor (var j = 0; j < aggregates[i].length; j++) {\n\t\t\t\t\t\titems.push(data[0][aggregates[i][j].alias] || null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titems.unshift(null);\n\n\t\t\t\treturn cb.apply(null, items);\n\t\t\t});\n\t\t}\n\t};\n\n\tfor (var i = 0; i < opts.driver.aggregate_functions.length; i++) {\n\t\taddAggregate(proto, opts.driver.aggregate_functions[i], appendFunction);\n\t}\n\n\treturn proto;\n}\n\nfunction addAggregate(proto, fun, builder) {\n\tif (Array.isArray(fun)) {\n\t\tproto[fun[0].toLowerCase()] = builder((fun[1] || fun[0]).toLowerCase());\n\t} else {\n\t\tproto[fun.toLowerCase()] = builder(fun.toLowerCase());\n\t}\n}\n\nfunction aggregateAlias(fun, fields) {\n\treturn fun + (fields && fields.length ? \"_\" + fields.join(\"_\") : \"\");\n}\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Debug.js":"var util = require(\"util\");\nvar tty  = require(\"tty\");\n\nexports.sql = function (driver, sql) {\n\tvar fmt;\n\n\tif (tty.isatty(process.stdout)) {\n\t\tfmt = \"\\033[32;1m(orm/%s) \\033[34m%s\\033[0m\\n\";\n\t\tsql = sql.replace(/`(.+?)`/g, function (m) { return \"\\033[31m\" + m + \"\\033[34m\"; });\n\t} else {\n\t\tfmt = \"[SQL/%s] %s\\n\";\n\t}\n\n\tprocess.stdout.write(util.format(fmt, driver, sql));\n};\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/ErrorCodes.js":"// Moved to 'Error.js'\nmodule.exports = require('./error').codes;\n","/home/travis/build/npmtest/node-npmtest-orm/node_modules/orm/lib/Express.js":"var orm      = require(\"./ORM\");\nvar _models  = {};\nvar _db      = null;\nvar _pending = 0;\nvar _queue   = [];\n\nmodule.exports = function (uri, opts) {\n\topts = opts || {};\n\n\t_pending += 1;\n\n\torm.connect(uri, function (err, db) {\n\t\tif (err) {\n\t\t\tif (typeof opts.error === \"function\") {\n\t\t\t\topts.error(err);\n\t\t\t} else {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\treturn checkRequestQueue();\n\t\t}\n\n\t\tif (Array.isArray(_db)) {\n\t\t\t_db.push(db);\n\t\t} else if (_db !== null) {\n\t\t\t_db = [ _db, db ];\n\t\t} else {\n\t\t\t_db = db;\n\t\t}\n\n\t\tif (typeof opts.define === \"function\") {\n\t\t\tif (opts.define.length > 2) {\n\t\t\t\treturn opts.define(db, _models, function () {\n\t\t\t\t\treturn checkRequestQueue();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\topts.define(db, _models);\n\t\t}\n\n\t\treturn checkRequestQueue();\n\t});\n\n\treturn function ORM_ExpressMiddleware(req, res, next) {\n\t\tif (!req.hasOwnProperty(\"models\")) {\n\t\t\treq.models = _models;\n\t\t\treq.db     = _db;\n\t\t}\n\n\t\tif (next === undefined && typeof res === 'function')\n\t\t{\n\t\t\tnext = res;\n\t\t}\n\n\t\tif (_pending > 0) {\n\t\t\t_queue.push(next);\n\t\t\treturn;\n\t\t}\n\n\t\treturn next();\n\t};\n};\n\nfunction checkRequestQueue() {\n\t_pending -= 1;\n\n\tif (_pending > 0) return;\n\tif (_queue.length === 0) return;\n\n\tfor (var i = 0; i < _queue.length; i++) {\n\t\t_queue[i]();\n\t}\n\n\t_queue.length = 0;\n}\n"}